============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-7.1.3, pluggy-1.0.0 -- /home/albina/Dev/django_sprint4/venv/bin/python3
django: settings: blogicum.settings (from ini)
rootdir: /home/albina/Dev/django_sprint4, configfile: pytest.ini, testpaths: tests/
plugins: Faker-12.0.1, django-4.5.2
collecting ... collected 25 items

tests/test_content.py::TestContent::test_unpublished FAILED              [  4%]
tests/test_content.py::TestContent::test_only_own_pubs_in_category FAILED [  8%]
tests/test_content.py::TestContent::test_only_own_pubs_in_profile FAILED [ 12%]
tests/test_content.py::TestContent::test_unpublished_category FAILED     [ 16%]
tests/test_content.py::TestContent::test_future_posts FAILED             [ 20%]
tests/test_content.py::TestContent::test_pagination FAILED               [ 24%]
tests/test_content.py::TestContent::test_image_visible FAILED            [ 28%]
tests/test_err_pages.py::test_custom_err_handlers FAILED                 [ 32%]
tests/test_users.py::test_custom_err_handlers FAILED                     [ 36%]
tests/test_users.py::test_profile FAILED                                 [ 40%]
tests/test_comment.py::test_comment_created_at PASSED                    [ 44%]
tests/test_comment.py::test_comment ERROR                                [ 48%]
tests/test_comment.py::test_404_on_comment_deleted_post ERROR            [ 52%]
tests/test_post.py::test_post_created_at PASSED                          [ 56%]
tests/test_post.py::test_post ERROR                                      [ 60%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field] <- tests/conftest.py PASSED [ 64%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field] <- tests/conftest.py PASSED [ 68%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field] <- tests/conftest.py PASSED [ 72%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field] <- tests/conftest.py PASSED [ 76%]
tests/test_emails.py::test_gitignore PASSED                              [ 80%]
tests/test_emails.py::test_email_backend_settings PASSED                 [ 84%]
tests/test_err_pages.py::test_csrf_failure_view FAILED                   [ 88%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`image` field] <- tests/conftest.py PASSED [ 92%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`pub_date` field] <- tests/conftest.py PASSED [ 96%]
tests/test_static_pages.py::test_static_pages_as_cbv FAILED              [100%]

==================================== ERRORS ====================================
________________________ ERROR at setup of test_comment ________________________

user_client = <django.test.client.Client object at 0x7992b8ddeb90>
post_with_published_location = <Post: Art Wear Four Pattern Care Area>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7992b8dddb40>
request = <WSGIRequest: GET '/posts/2/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)
E               TypeError: View.as_view() takes 1 positional argument but 2 were given

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: TypeError
______________ ERROR at setup of test_404_on_comment_deleted_post ______________

user_client = <django.test.client.Client object at 0x7992b8fd5b40>
post_with_published_location = <Post: Subject They Any Likely Onto Word>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7992b8fd47f0>
request = <WSGIRequest: GET '/posts/3/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)
E               TypeError: View.as_view() takes 1 positional argument but 2 were given

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: TypeError
_________________________ ERROR at setup of test_post __________________________

user_client = <django.test.client.Client object at 0x7992b8c0ea40>
post_with_published_location = <Post: Yet Hotel Share Professor She Spring>

    @pytest.fixture
    def create_post_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_create_a_post_get_response_safely(user_client)

tests/fixtures/posts.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:275: in get_create_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7992b8c0c070>
request = <WSGIRequest: GET '/posts/create/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)
E               TypeError: View.as_view() takes 1 positional argument but 2 were given

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: TypeError
=================================== FAILURES ===================================
_________________________ TestContent.test_unpublished _________________________

self = <test_content.ProfilePostContentTester object at 0x7992b9135690>
client = <django.test.client.Client object at 0x7992b9173fd0>
url = '/profile/barry57/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7992b93ec6a0>
unpublished_posts_with_published_locations = [<Post: Apply Radio Why Somebody Skill Home>, <Post: Capital Type Outside Ago Receive Than>, <Post: Pay Deal Moment It Show Season>]

    def test_unpublished(self, unpublished_posts_with_published_locations):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7992b9135690>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
__________________ TestContent.test_only_own_pubs_in_category __________________

self = <test_content.CategoryPostContentTester object at 0x7992b91368f0>
client = <django.test.client.Client object at 0x7992b9137eb0>
url = '/category/agreement-exactly/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7992b9137eb0>
path = '/category/agreement-exactly/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7992b9137eb0>
path = '/category/agreement-exactly/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7992b9137eb0>, method = 'GET'
path = '/category/agreement-exactly/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/agreement-exactly/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/agreement-exactly/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7992b9137eb0>
request = {'PATH_INFO': '/category/agreement-exactly/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=nhceg1efy4esc0lwd8g0e1xeupjx48xf', 'PATH_INFO': '/category/agreement-exactly/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': True, 'unicode_hint': '', 'frames': [{'exc_ca...mmon error).'], 'pre_context_lineno': 174}}]], 'templates': [<django.template.base.Template object at 0x7992b8fd7640>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7992b9b70e50>, {'templates': [<django.template.base.Template...         raise', '', '        # Complain if the view returned None (a common error).'], 'pre_context_lineno': 174}}]]})
signal_uid = 'template-render-133671074222400'
exception_uid = 'request-exception-133671074222400'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7992b9137eb0>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/agreement-exactly/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7992b91369e0>
request = <WSGIRequest: GET '/category/agreement-exactly/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)
E               TypeError: View.as_view() takes 1 positional argument but 2 were given

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: TypeError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7992b93ec700>
user_client = <django.test.client.Client object at 0x7992b9137eb0>
post_with_published_location = <Post: Specific Blue Television Have Arm Rule>
post_with_another_category = <Post: Week Door The Vote Image Of>

    def test_only_own_pubs_in_category(
        self, user_client, post_with_published_location,
            post_with_another_category
    ):
>       response = self.category_tester.user_client_testget()

tests/test_content.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.CategoryPostContentTester object at 0x7992b91368f0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница категории загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница категории загружается без ошибок.

tests/test_content.py:266: AssertionError
__________________ TestContent.test_only_own_pubs_in_profile ___________________

self = <test_content.ProfilePostContentTester object at 0x7992b8c33520>
client = <django.test.client.Client object at 0x7992b8c32fb0>
url = '/profile/kolsen/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7992b93ecd30>
user_client = <django.test.client.Client object at 0x7992b8c32fb0>
post_with_published_location = <Post: Factor Visit Safe Music Act None>
post_of_another_author = <Post: Set Name Fish Manage Region West>

    def test_only_own_pubs_in_profile(
            self, user_client, post_with_published_location,
            post_of_another_author
    ):
>       response = self.profile_tester.user_client_testget()

tests/test_content.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7992b8c33520>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
____________________ TestContent.test_unpublished_category _____________________

self = <test_content.ProfilePostContentTester object at 0x7992b8c06350>
client = <django.test.client.Client object at 0x7992b8c06d10>
url = '/profile/kellerjonathon/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7992b938bbb0>
user_client = <django.test.client.Client object at 0x7992b8c06d10>
posts_with_unpublished_category = [<Post: Important Name Poor Community By Shoulder>, <Post: Large Member There Pass In Television>, <Post: Plant Majority Something Light Natural Result>]

    def test_unpublished_category(
        self, user_client, posts_with_unpublished_category
    ):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7992b8c06350>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_future_posts _________________________

self = <test_content.ProfilePostContentTester object at 0x7992b8c33a00>
client = <django.test.client.Client object at 0x7992b8c32080>
url = '/profile/kaiserhayden/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7992b93ec610>
user_client = <django.test.client.Client object at 0x7992b8c32080>
future_posts = [<Post: Hold Detail Public Tell Behind Management>, <Post: Process Unit Nor Through Consider Stuff>, <Post: Close Nation Gas Near Back Off>]

    def test_future_posts(self, user_client, future_posts):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:441: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7992b8c33a00>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
_________________________ TestContent.test_pagination __________________________

self = <test_content.ProfilePostContentTester object at 0x7992b8c06d40>
client = <django.test.client.Client object at 0x7992b8c04730>
url = '/profile/loganfranco/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7992b93ec670>
user_client = <django.test.client.Client object at 0x7992b8c04730>
many_posts_with_published_locations = [<Post: Action Little Right Always Forward Fast>, <Post: Weight Long Avoid Space Pay Move>, <Post: Sell Treat Try Reso...e Significant Report>, <Post: Also Space Station Yeah Hold Participant>, <Post: Test True Wait Dark Quickly Must>, ...]

    def test_pagination(
        self, user_client, many_posts_with_published_locations
    ):
        posts = many_posts_with_published_locations
    
        assert len(posts) > self.profile_tester.n_per_page
        assert len(posts) > self.main_tester.n_per_page
        assert len(posts) > self.category_tester.n_per_page
    
        for (
            tester,
            response_get_func,
            ordering_err_msg,
            pagination_err_msg,
        ) in (
            (
                self.profile_tester,
                self.profile_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора работает"
                    " пагинация."
                ),
            ),
            (
                self.profile_tester,
                self.profile_tester.another_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора "
                    "пагинация работает в соответствии с заданием ."
                ),
            ),
            (
                self.main_tester,
                self.main_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст главной"
                    " страницы отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на главной странице "
                "пагинация работает в соответствии с заданием .",
            ),
            (
                self.category_tester,
                self.category_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " категории отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на странице категории "
                "пагинация работает в соответствии с заданием .",
            ),
        ):
>           response = response_get_func()

tests/test_content.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7992b8c06d40>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_image_visible ________________________

self = <test_content.ProfilePostContentTester object at 0x7992b8da0490>
client = <django.test.client.Client object at 0x7992b8da0910>
url = '/profile/deannagreen/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7992b93ee380>
user_client = <django.test.client.Client object at 0x7992b8da0910>
post_with_published_location = <Post: Believe Around Deal Again Painting People>

    def test_image_visible(self, user_client, post_with_published_location):
        post = post_with_published_location
        post_adapter = PostModelAdapter(post)
    
        testers: List[PostContentTester] = [
            self.profile_tester,
            self.main_tester,
            self.category_tester,
        ]
        img_n_with_post_img = {}
    
        for i, tester in enumerate(testers):
            img_soup_with_post_img = BeautifulSoup(
>               tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )

tests/test_content.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7992b8da0490>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x7992b8c043d0>
user_client = <django.test.client.Client object at 0x7992b8c06920>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
>               fpath = settings.TEMPLATES_DIR / "pages" / fname

tests/test_err_pages.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <LazySettings "None">, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        """Return the value of a setting and cache it in self.__dict__."""
        if self._wrapped is empty:
            self._setup(name)
>       val = getattr(self._wrapped, name)

venv/lib/python3.10/site-packages/django/conf/__init__.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <UserSettingsHolder>, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        if not name.isupper() or name in self._deleted:
            raise AttributeError
>       return getattr(self.default_settings, name)
E       AttributeError: 'Settings' object has no attribute 'TEMPLATES_DIR'

venv/lib/python3.10/site-packages/django/conf/__init__.py:239: AttributeError

During handling of the above exception, another exception occurred:

client = <django.test.client.Client object at 0x7992b8c043d0>
user_client = <django.test.client.Client object at 0x7992b8c06920>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
                fpath = settings.TEMPLATES_DIR / "pages" / fname
            except Exception as e:
>               raise AssertionError(
                    'Убедитесь, что переменная TEMPLATES_DIR в настройках проекта '
                    'является строкой (str) или объектом, соответствующим path-like интерфейсу '
                    '(например, экземпляром pathlib.Path). '
                    f'При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: {e}'
                )
E               AssertionError: Убедитесь, что переменная TEMPLATES_DIR в настройках проекта является строкой (str) или объектом, соответствующим path-like интерфейсу (например, экземпляром pathlib.Path). При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: 'Settings' object has no attribute 'TEMPLATES_DIR'

tests/test_err_pages.py:57: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x7992b8da3d30>

    @pytest.mark.django_db
    def test_custom_err_handlers(client):
        try:
            from blogicum import urls as blogicum_urls
        except Exception:
            raise AssertionError(
                "Убедитесь, в головном файле с маршрутами нет ошибок."
            )
        urls_src_squashed = squash_code(inspect.getsource(blogicum_urls))
        if "django.contrib.auth.urls" not in urls_src_squashed:
            raise AssertionError(
                "Убедитесь, что подключены маршруты для работы с пользователями из"
                " `django.contrib.auth.urls`."
            )
    
        def search_url_patterns(substring):
            resolver = get_resolver()
            results = []
    
            def search_patterns(head, patterns):
                for pattern in patterns:
                    if isinstance(pattern, URLPattern):
                        pattern_as_str = head + str(pattern.pattern)
                        if substring in pattern_as_str:
                            results.append(pattern)
                    elif isinstance(pattern, URLResolver):
                        search_patterns(
                            head + str(pattern.pattern), pattern.url_patterns
                        )
                return results
    
            search_patterns(head="", patterns=resolver.url_patterns)
    
            return results
    
        registration_url = "auth/registration/"
        auth_registration_patterns = search_url_patterns(registration_url)
>       assert auth_registration_patterns, (
            "Убедитесь, что в головном файле с маршрутами переопределён маршрут"
            f" `{registration_url}`."
        )
E       AssertionError: Убедитесь, что в головном файле с маршрутами переопределён маршрут `auth/registration/`.
E       assert []

tests/test_users.py:62: AssertionError
_________________________________ test_profile _________________________________

user = <User: candace19>, another_user = <User: mary77>
user_client = <django.test.client.Client object at 0x7992b8c1b0a0>
another_user_client = <django.test.client.Client object at 0x7992b8c1b160>
unlogged_client = <django.test.client.Client object at 0x7992b8c18520>

    @pytest.mark.django_db
    def test_profile(
            user, another_user, user_client, another_user_client, unlogged_client
    ):
        user_url = f"/profile/{user.username}/"
        printed_url = "/profile/<username>/"
    
        User = get_user_model()
        status_code_not_404_err_msg = (
            "Убедитесь, что при обращении к странице несуществующего "
            "пользователя возвращается статус 404."
        )
        try:
            response = user_client.get("/profile/this_is_unexisting_user_name/")
        except User.DoesNotExist:
            raise AssertionError(status_code_not_404_err_msg)
    
        assert response.status_code == HTTPStatus.NOT_FOUND, (
            status_code_not_404_err_msg)
    
        user_response: HttpResponse = user_client.get(user_url)
    
        user_content = user_response.content.decode("utf-8")
    
        anothers_same_page_response: HttpResponse = another_user_client.get(
            user_url
        )
        anothers_same_page_content = anothers_same_page_response.content.decode(
            "utf-8"
        )
    
        unlogged_same_page_response: HttpResponse = unlogged_client.get(user_url)
        unlogged_same_page_content = unlogged_same_page_response.content.decode(
            "utf-8"
        )
    
        for profile_user, profile_user_content in (
                (user, user_content),
                (user, unlogged_same_page_content),
                (user, anothers_same_page_content),
        ):
>           _test_user_info_displayed(
                profile_user, profile_user_content, printed_url
            )

tests/test_users.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

profile_user = <User: candace19>
profile_user_content = '\n<!doctype html>\n<html lang="en">\n<head>\n  <title>Not Found</title>\n</head>\n<body>\n  <h1>Not Found</h1><p>The requested resource was not found on this server.</p>\n</body>\n</html>\n'
printed_url = '/profile/<username>/'

    def _test_user_info_displayed(
            profile_user: Model, profile_user_content: str, printed_url: str
    ) -> None:
        if profile_user.first_name not in profile_user_content:
>           raise AssertionError(
                f"Убедитесь, что на странице `{printed_url}` отображается имя"
                " пользователя."
            )
E           AssertionError: Убедитесь, что на странице `/profile/<username>/` отображается имя пользователя.

tests/test_users.py:182: AssertionError
____________________________ test_csrf_failure_view ____________________________

parser = <django.template.base.Parser object at 0x7992b91e4d30>
name = 'django_bootstrap5'

    def find_library(parser, name):
        try:
>           return parser.libraries[name]
E           KeyError: 'django_bootstrap5'

venv/lib/python3.10/site-packages/django/template/defaulttags.py:1037: KeyError

During handling of the above exception, another exception occurred:

    def test_csrf_failure_view():
        csrf_failure_view_setting = getattr(settings, "CSRF_FAILURE_VIEW", "")
        module_name, function_name = csrf_failure_view_setting.rsplit(".", 1)
        csrf_failure_view = None
        try:
            module = import_module(module_name)
            csrf_failure_view = getattr(module, function_name, None)
        except Exception:
            pass
        assert csrf_failure_view, (
            "Убедитесь, что в `settings.py` задана настройка `CSRF_FAILURE_VIEW` и"
            " что она указывает на существующую view-функцию."
        )
    
        request = HttpRequest()
        request.method = "POST"
        request.POST = {}
    
        try:
>           response = csrf_failure_view(request)

tests/test_err_pages.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <HttpRequest>, reason = ''

    def csrf_failure(request, reason='') -> HttpResponse:
        """Ошибка 403: Ошибка CSRF токена."""
>       return render(request, 'pages/403csrf.html', status=403)

blogicum/pages/views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <HttpRequest>, template_name = 'pages/403csrf.html', context = None
content_type = None, status = 403, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv/lib/python3.10/site-packages/django/shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

template_name = 'pages/403csrf.html', context = None, request = <HttpRequest>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv/lib/python3.10/site-packages/django/template/loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7992b91de080>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <HttpRequest>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7992b91dea40>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7992b91dea40>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
>       compiled_parent = self.get_parent(context)

venv/lib/python3.10/site-packages/django/template/loader_tags.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def get_parent(self, context):
        parent = self.parent_name.resolve(context)
        if not parent:
            error_msg = "Invalid template name in 'extends' tag: %r." % parent
            if self.parent_name.filters or\
                    isinstance(self.parent_name.var, Variable):
                error_msg += " Got this from the '%s' variable." %\
                    self.parent_name.token
            raise TemplateSyntaxError(error_msg)
        if isinstance(parent, Template):
            # parent is a django.template.Template
            return parent
        if isinstance(getattr(parent, 'template', None), Template):
            # parent is a django.template.backends.django.Template
            return parent.template
>       return self.find_template(parent, context)

venv/lib/python3.10/site-packages/django/template/loader_tags.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">, template_name = 'base.html'
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def find_template(self, template_name, context):
        """
        This is a wrapper around engine.find_template(). A history is kept in
        the render_context attribute between successive extends calls and
        passed as the skip argument. This enables extends to work recursively
        without extending the same template twice.
        """
        history = context.render_context.setdefault(
            self.context_key, [self.origin],
        )
>       template, origin = context.template.engine.find_template(
            template_name, skip=history,
        )

venv/lib/python3.10/site-packages/django/template/loader_tags.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.engine.Engine object at 0x7992b91dc100>
name = 'base.html', dirs = None
skip = [<django.template.base.Origin object at 0x7992b91dea70>]

    def find_template(self, name, dirs=None, skip=None):
        tried = []
        for loader in self.template_loaders:
            try:
>               template = loader.get_template(name, skip=skip)

venv/lib/python3.10/site-packages/django/template/engine.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.loaders.cached.Loader object at 0x7992b91dd180>
template_name = 'base.html'
skip = [<django.template.base.Origin object at 0x7992b91dea70>]

    def get_template(self, template_name, skip=None):
        """
        Perform the caching that gives this loader its name. Often many of the
        templates attempted will be missing, so memory use is of concern here.
        To keep it in check, caching behavior is a little complicated when a
        template is not found. See ticket #26306 for more details.
    
        With template debugging disabled, cache the TemplateDoesNotExist class
        for every missing template and raise a new instance of it after
        fetching it from the cache.
    
        With template debugging enabled, a unique TemplateDoesNotExist object
        is cached for each missing template to preserve debug data. When
        raising an exception, Python sets __traceback__, __context__, and
        __cause__ attributes on it. Those attributes can contain references to
        all sorts of objects up the call chain and caching them creates a
        memory leak. Thus, unraised copies of the exceptions are cached and
        copies of those copies are raised after they're fetched from the cache.
        """
        key = self.cache_key(template_name, skip)
        cached = self.get_template_cache.get(key)
        if cached:
            if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):
                raise cached(template_name)
            elif isinstance(cached, TemplateDoesNotExist):
                raise copy_exception(cached)
            return cached
    
        try:
>           template = super().get_template(template_name, skip)

venv/lib/python3.10/site-packages/django/template/loaders/cached.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.loaders.cached.Loader object at 0x7992b91dd180>
template_name = 'base.html'
skip = [<django.template.base.Origin object at 0x7992b91dea70>]

    def get_template(self, template_name, skip=None):
        """
        Call self.get_template_sources() and return a Template object for
        the first template matching template_name. If skip is provided, ignore
        template origins in skip. This is used to avoid recursion during
        template extending.
        """
        tried = []
    
        for origin in self.get_template_sources(template_name):
            if skip is not None and origin in skip:
                tried.append((origin, 'Skipped to avoid recursion'))
                continue
    
            try:
                contents = self.get_contents(origin)
            except TemplateDoesNotExist:
                tried.append((origin, 'Source does not exist'))
                continue
            else:
>               return Template(
                    contents, origin, origin.template_name, self.engine,
                )

venv/lib/python3.10/site-packages/django/template/loaders/base.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7992b91e4040>
template_string = '{% load static %}\n{% load django_bootstrap5 %}\n<!DOCTYPE html>\n<html lang="ru">\n  <head>\n    <meta charset="utf-...lock content %}{% endblock %}\n      </div>\n    </main>\n    {% include "includes/footer.html" %}\n  </body>\n</html>'
origin = <django.template.base.Origin object at 0x7992b91e4160>
name = 'base.html'
engine = <django.template.engine.Engine object at 0x7992b91dc100>

    def __init__(self, template_string, origin=None, name=None, engine=None):
        # If Template is instantiated directly rather than from an Engine and
        # exactly one Django template engine is configured, use that engine.
        # This is required to preserve backwards-compatibility for direct use
        # e.g. Template('...').render(Context({...}))
        if engine is None:
            from .engine import Engine
            engine = Engine.get_default()
        if origin is None:
            origin = Origin(UNKNOWN_SOURCE)
        self.name = name
        self.origin = origin
        self.engine = engine
        self.source = str(template_string)  # May be lazy.
>       self.nodelist = self.compile_nodelist()

venv/lib/python3.10/site-packages/django/template/base.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7992b91e4040>

    def compile_nodelist(self):
        """
        Parse and compile the template source into a nodelist. If debug
        is True and an exception occurs during parsing, the exception is
        annotated with contextual line information where it occurred in the
        template source.
        """
        if self.engine.debug:
            lexer = DebugLexer(self.source)
        else:
            lexer = Lexer(self.source)
    
        tokens = lexer.tokenize()
        parser = Parser(
            tokens, self.engine.template_libraries, self.engine.template_builtins,
            self.origin,
        )
    
        try:
>           return parser.parse()

venv/lib/python3.10/site-packages/django/template/base.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Parser object at 0x7992b91e4d30>, parse_until = []

    def parse(self, parse_until=None):
        """
        Iterate through the parser tokens and compiles each one into a node.
    
        If parse_until is provided, parsing will stop once one of the
        specified tokens has been reached. This is formatted as a list of
        tokens, e.g. ['elif', 'else', 'endif']. If no matching token is
        reached, raise an exception with the unclosed block tag details.
        """
        if parse_until is None:
            parse_until = []
        nodelist = NodeList()
        while self.tokens:
            token = self.next_token()
            # Use the raw values here for TokenType.* for a tiny performance boost.
            if token.token_type.value == 0:  # TokenType.TEXT
                self.extend_nodelist(nodelist, TextNode(token.contents), token)
            elif token.token_type.value == 1:  # TokenType.VAR
                if not token.contents:
                    raise self.error(token, 'Empty variable tag on line %d' % token.lineno)
                try:
                    filter_expression = self.compile_filter(token.contents)
                except TemplateSyntaxError as e:
                    raise self.error(token, e)
                var_node = VariableNode(filter_expression)
                self.extend_nodelist(nodelist, var_node, token)
            elif token.token_type.value == 2:  # TokenType.BLOCK
                try:
                    command = token.contents.split()[0]
                except IndexError:
                    raise self.error(token, 'Empty block tag on line %d' % token.lineno)
                if command in parse_until:
                    # A matching token has been reached. Return control to
                    # the caller. Put the token back on the token list so the
                    # caller knows where it terminated.
                    self.prepend_token(token)
                    return nodelist
                # Add the token to the command stack. This is used for error
                # messages if further parsing fails due to an unclosed block
                # tag.
                self.command_stack.append((command, token))
                # Get the tag callback function from the ones registered with
                # the parser.
                try:
                    compile_func = self.tags[command]
                except KeyError:
                    self.invalid_block_tag(token, command, parse_until)
                # Compile the callback into a node object and add it to
                # the node list.
                try:
                    compiled_result = compile_func(self, token)
                except Exception as e:
>                   raise self.error(token, e)

venv/lib/python3.10/site-packages/django/template/base.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Parser object at 0x7992b91e4d30>, parse_until = []

    def parse(self, parse_until=None):
        """
        Iterate through the parser tokens and compiles each one into a node.
    
        If parse_until is provided, parsing will stop once one of the
        specified tokens has been reached. This is formatted as a list of
        tokens, e.g. ['elif', 'else', 'endif']. If no matching token is
        reached, raise an exception with the unclosed block tag details.
        """
        if parse_until is None:
            parse_until = []
        nodelist = NodeList()
        while self.tokens:
            token = self.next_token()
            # Use the raw values here for TokenType.* for a tiny performance boost.
            if token.token_type.value == 0:  # TokenType.TEXT
                self.extend_nodelist(nodelist, TextNode(token.contents), token)
            elif token.token_type.value == 1:  # TokenType.VAR
                if not token.contents:
                    raise self.error(token, 'Empty variable tag on line %d' % token.lineno)
                try:
                    filter_expression = self.compile_filter(token.contents)
                except TemplateSyntaxError as e:
                    raise self.error(token, e)
                var_node = VariableNode(filter_expression)
                self.extend_nodelist(nodelist, var_node, token)
            elif token.token_type.value == 2:  # TokenType.BLOCK
                try:
                    command = token.contents.split()[0]
                except IndexError:
                    raise self.error(token, 'Empty block tag on line %d' % token.lineno)
                if command in parse_until:
                    # A matching token has been reached. Return control to
                    # the caller. Put the token back on the token list so the
                    # caller knows where it terminated.
                    self.prepend_token(token)
                    return nodelist
                # Add the token to the command stack. This is used for error
                # messages if further parsing fails due to an unclosed block
                # tag.
                self.command_stack.append((command, token))
                # Get the tag callback function from the ones registered with
                # the parser.
                try:
                    compile_func = self.tags[command]
                except KeyError:
                    self.invalid_block_tag(token, command, parse_until)
                # Compile the callback into a node object and add it to
                # the node list.
                try:
>                   compiled_result = compile_func(self, token)

venv/lib/python3.10/site-packages/django/template/base.py:476: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

parser = <django.template.base.Parser object at 0x7992b91e4d30>
token = <django.template.base.Token object at 0x7992b91e4880>

    @register.tag
    def load(parser, token):
        """
        Load a custom template tag library into the parser.
    
        For example, to load the template tags in
        ``django/templatetags/news/photos.py``::
    
            {% load news.photos %}
    
        Can also be used to load an individual tag/filter from
        a library::
    
            {% load byline from news %}
        """
        # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments
        bits = token.contents.split()
        if len(bits) >= 4 and bits[-2] == "from":
            # from syntax is used; load individual tags from the library
            name = bits[-1]
            lib = find_library(parser, name)
            subset = load_from_library(lib, name, bits[1:-2])
            parser.add_library(subset)
        else:
            # one or more libraries are specified; load and add them to the parser
            for name in bits[1:]:
>               lib = find_library(parser, name)

venv/lib/python3.10/site-packages/django/template/defaulttags.py:1094: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

parser = <django.template.base.Parser object at 0x7992b91e4d30>
name = 'django_bootstrap5'

    def find_library(parser, name):
        try:
            return parser.libraries[name]
        except KeyError:
>           raise TemplateSyntaxError(
                "'%s' is not a registered tag library. Must be one of:\n%s" % (
                    name, "\n".join(sorted(parser.libraries)),
                ),
            )
E           django.template.exceptions.TemplateSyntaxError: 'django_bootstrap5' is not a registered tag library. Must be one of:
E           admin_list
E           admin_modify
E           admin_urls
E           cache
E           i18n
E           l10n
E           log
E           static
E           tz

venv/lib/python3.10/site-packages/django/template/defaulttags.py:1039: TemplateSyntaxError

During handling of the above exception, another exception occurred:

    def test_csrf_failure_view():
        csrf_failure_view_setting = getattr(settings, "CSRF_FAILURE_VIEW", "")
        module_name, function_name = csrf_failure_view_setting.rsplit(".", 1)
        csrf_failure_view = None
        try:
            module = import_module(module_name)
            csrf_failure_view = getattr(module, function_name, None)
        except Exception:
            pass
        assert csrf_failure_view, (
            "Убедитесь, что в `settings.py` задана настройка `CSRF_FAILURE_VIEW` и"
            " что она указывает на существующую view-функцию."
        )
    
        request = HttpRequest()
        request.method = "POST"
        request.POST = {}
    
        try:
            response = csrf_failure_view(request)
        except Exception:
>           raise AssertionError(
                f"Убедитесь, что view-функция `{csrf_failure_view_setting}`"
                " работает без ошибок."
            )
E           AssertionError: Убедитесь, что view-функция `pages.views.csrf_failure` работает без ошибок.

tests/test_err_pages.py:34: AssertionError
___________________________ test_static_pages_as_cbv ___________________________

    def test_static_pages_as_cbv():
        try:
            from pages import urls
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `pages/urls.py` нет ошибок. При его"
                f" импорте возникла ошибка:\n{type(e).__name__}: {e}"
            )
        try:
            from pages.urls import urlpatterns
        except Exception:
            raise AssertionError(
                "Убедитесь, что в файле `pages/urls.py` задан список urlpatterns."
            )
        try:
            from pages.urls import app_name
        except Exception:
            raise AssertionError(
                "Убедитесь, что в файле `pages/urls.py` определена глобальная"
                " переменная `app_name`, задающая пространство имён url для"
                " приложения `pages`."
            )
        for path in urlpatterns:
            if not hasattr(path.callback, "view_class"):
>               raise AssertionError(
                    "Убедитесь, что в файле `pages/urls.py` маршруты статических"
                    " страниц подключены с помощью CBV."
                )
E               AssertionError: Убедитесь, что в файле `pages/urls.py` маршруты статических страниц подключены с помощью CBV.

tests/test_static_pages.py:25: AssertionError
=========================== short test summary info ============================
ERROR tests/test_comment.py::test_comment - TypeError: View.as_view() takes 1...
ERROR tests/test_comment.py::test_404_on_comment_deleted_post - TypeError: Vi...
ERROR tests/test_post.py::test_post - TypeError: View.as_view() takes 1 posit...
=================== 12 failed, 10 passed, 3 errors in 1.17s ====================
