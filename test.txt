============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-7.1.3, pluggy-1.0.0 -- /home/albina/Dev/django_sprint4/venv/bin/python3
django: settings: blogicum.settings (from ini)
rootdir: /home/albina/Dev/django_sprint4, configfile: pytest.ini, testpaths: tests/
plugins: Faker-12.0.1, django-4.5.2
collecting ... collected 25 items

tests/test_content.py::TestContent::test_unpublished FAILED              [  4%]
tests/test_content.py::TestContent::test_only_own_pubs_in_category PASSED [  8%]
tests/test_content.py::TestContent::test_only_own_pubs_in_profile FAILED [ 12%]
tests/test_content.py::TestContent::test_unpublished_category FAILED     [ 16%]
tests/test_content.py::TestContent::test_future_posts FAILED             [ 20%]
tests/test_content.py::TestContent::test_pagination FAILED               [ 24%]
tests/test_content.py::TestContent::test_image_visible FAILED            [ 28%]
tests/test_err_pages.py::test_custom_err_handlers FAILED                 [ 32%]
tests/test_users.py::test_custom_err_handlers FAILED                     [ 36%]
tests/test_users.py::test_profile FAILED                                 [ 40%]
tests/test_comment.py::test_comment_created_at PASSED                    [ 44%]
tests/test_comment.py::test_comment ERROR                                [ 48%]
tests/test_comment.py::test_404_on_comment_deleted_post ERROR            [ 52%]
tests/test_post.py::test_post_created_at PASSED                          [ 56%]
tests/test_post.py::test_post FAILED                                     [ 60%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field] <- tests/conftest.py PASSED [ 64%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field] <- tests/conftest.py PASSED [ 68%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field] <- tests/conftest.py PASSED [ 72%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field] <- tests/conftest.py PASSED [ 76%]
tests/test_emails.py::test_gitignore PASSED                              [ 80%]
tests/test_emails.py::test_email_backend_settings PASSED                 [ 84%]
tests/test_err_pages.py::test_csrf_failure_view PASSED                   [ 88%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`image` field] <- tests/conftest.py PASSED [ 92%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`pub_date` field] <- tests/conftest.py PASSED [ 96%]
tests/test_static_pages.py::test_static_pages_as_cbv PASSED              [100%]

==================================== ERRORS ====================================
________________________ ERROR at setup of test_comment ________________________

user_client = <django.test.client.Client object at 0x7ebc1c389270>
post_with_published_location = <Post: Short Their Officer Down Coach Nothing>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: in _get_response
    response = response.render()
venv/lib/python3.10/site-packages/django/template/response.py:105: in render
    self.content = self.rendered_content
venv/lib/python3.10/site-packages/django/template/response.py:83: in rendered_content
    return template.render(context, self._request)
venv/lib/python3.10/site-packages/django/template/backends/django.py:61: in render
    return self.template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:170: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: in render
    return compiled_parent._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: in render
    result = block.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: in render
    return nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
venv/lib/python3.10/site-packages/django/urls/base.py:86: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/albina/Dev/django_sprint4/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_post', _prefix = '/', args = (2,), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_post' not found. 'edit_post' is not a valid view function or pattern name.

venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch
______________ ERROR at setup of test_404_on_comment_deleted_post ______________

user_client = <django.test.client.Client object at 0x7ebc1cac9e40>
post_with_published_location = <Post: Look Four Far Success Bank Both>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: in _get_response
    response = response.render()
venv/lib/python3.10/site-packages/django/template/response.py:105: in render
    self.content = self.rendered_content
venv/lib/python3.10/site-packages/django/template/response.py:83: in rendered_content
    return template.render(context, self._request)
venv/lib/python3.10/site-packages/django/template/backends/django.py:61: in render
    return self.template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:170: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: in render
    return compiled_parent._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: in render
    result = block.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: in render
    return nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
venv/lib/python3.10/site-packages/django/urls/base.py:86: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/albina/Dev/django_sprint4/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_post', _prefix = '/', args = (3,), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_post' not found. 'edit_post' is not a valid view function or pattern name.

venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch
=================================== FAILURES ===================================
_________________________ TestContent.test_unpublished _________________________

self = <test_content.ProfilePostContentTester object at 0x7ebc1d1c76a0>
client = <django.test.client.Client object at 0x7ebc1d057c40>
url = '/profile/pedro98/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d057c40>
path = '/profile/pedro98/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d057c40>
path = '/profile/pedro98/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d057c40>, method = 'GET'
path = '/profile/pedro98/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/pedro98/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/pedro98/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d057c40>
request = {'PATH_INFO': '/profile/pedro98/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=y0tey47b4h1meds4h9coa0r4h8k1p7i4', 'PATH_INFO': '/profile/pedro98/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': True, 'unicode_hint': '', 'frames': [{'exc_ca...connection):'], 'pre_context_lineno': 290}}]], 'templates': [<django.template.base.Template object at 0x7ebc1ce8a380>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7ebc1da58f70>, {'templates': [<django.template.base.Template...process_rhs(compiler, connection)', '', '    def as_sql(self, compiler, connection):'], 'pre_context_lineno': 290}}]]})
signal_uid = 'template-render-139346406004992'
exception_uid = 'request-exception-139346406004992'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d057c40>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pedro98/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7ebc1d056fb0>
request = <WSGIRequest: GET '/profile/pedro98/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pedro98/'>, args = ()
kwargs = {'name_slug': 'pedro98'}
self = <blog.views.ProfileListView object at 0x7ebc1d07ac80>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d07ac80>
request = <WSGIRequest: GET '/profile/pedro98/'>, args = ()
kwargs = {'name_slug': 'pedro98'}
handler = <bound method BaseListView.get of <blog.views.ProfileListView object at 0x7ebc1d07ac80>>

    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
>       return handler(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d07ac80>
request = <WSGIRequest: GET '/profile/pedro98/'>, args = ()
kwargs = {'name_slug': 'pedro98'}, allow_empty = True

    def get(self, request, *args, **kwargs):
        self.object_list = self.get_queryset()
        allow_empty = self.get_allow_empty()
    
        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if self.get_paginate_by(self.object_list) is not None and hasattr(self.object_list, 'exists'):
                is_empty = not self.object_list.exists()
            else:
                is_empty = not self.object_list
            if is_empty:
                raise Http404(_('Empty list and “%(class_name)s.allow_empty” is False.') % {
                    'class_name': self.__class__.__name__,
                })
>       context = self.get_context_data()

venv/lib/python3.10/site-packages/django/views/generic/list.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d07ac80>, kwargs = {}

    def get_context_data(self, **kwargs) -> dict:
        """Добавляет в контекст сведения о профиле пользователя."""
>       context: dict = super().get_context_data(**kwargs)

blogicum/blog/views.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d07ac80>, object_list = None
kwargs = {}
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1ce48b80>
page_size = 10, context_object_name = 'post_list'

    def get_context_data(self, *, object_list=None, **kwargs):
        """Get the context for this view."""
        queryset = object_list if object_list is not None else self.object_list
        page_size = self.get_paginate_by(queryset)
        context_object_name = self.get_context_object_name(queryset)
        if page_size:
>           paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)

venv/lib/python3.10/site-packages/django/views/generic/list.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d07ac80>
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1ce48b80>
page_size = 10

    def paginate_queryset(self, queryset, page_size):
        """Paginate the queryset, if needed."""
        paginator = self.get_paginator(
            queryset, page_size, orphans=self.get_paginate_orphans(),
            allow_empty_first_page=self.get_allow_empty())
        page_kwarg = self.page_kwarg
        page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1
        try:
            page_number = int(page)
        except ValueError:
            if page == 'last':
                page_number = paginator.num_pages
            else:
                raise Http404(_('Page is not “last”, nor can it be converted to an int.'))
        try:
>           page = paginator.page(page_number)

venv/lib/python3.10/site-packages/django/views/generic/list.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1ce32200>, number = 1

    def page(self, number):
        """Return a Page object for the given 1-based page number."""
>       number = self.validate_number(number)

venv/lib/python3.10/site-packages/django/core/paginator.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1ce32200>, number = 1

    def validate_number(self, number):
        """Validate the given 1-based page number."""
        try:
            if isinstance(number, float) and not number.is_integer():
                raise ValueError
            number = int(number)
        except (TypeError, ValueError):
            raise PageNotAnInteger(_('That page number is not an integer'))
        if number < 1:
            raise EmptyPage(_('That page number is less than 1'))
>       if number > self.num_pages:

venv/lib/python3.10/site-packages/django/core/paginator.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28ddb0>
instance = <django.core.paginator.Paginator object at 0x7ebc1ce32200>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1ce32200>

    @cached_property
    def num_pages(self):
        """Return the total number of pages."""
>       if self.count == 0 and not self.allow_empty_first_page:

venv/lib/python3.10/site-packages/django/core/paginator.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28dd50>
instance = <django.core.paginator.Paginator object at 0x7ebc1ce32200>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1ce32200>

    @cached_property
    def count(self):
        """Return the total number of objects, across all pages."""
        c = getattr(self.object_list, 'count', None)
        if callable(c) and not inspect.isbuiltin(c) and method_has_no_args(c):
>           return c()

venv/lib/python3.10/site-packages/django/core/paginator.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1ce48b80>

    def count(self):
        """
        Perform a SELECT COUNT() and return the number of records as an
        integer.
    
        If the QuerySet is already fully cached, return the length of the
        cached results set to avoid multiple SELECT COUNT(*) calls.
        """
        if self._result_cache is not None:
            return len(self._result_cache)
    
>       return self.query.get_count(using=self.db)

venv/lib/python3.10/site-packages/django/db/models/query.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1ce162c0>
using = 'default'

    def get_count(self, using):
        """
        Perform a COUNT() query using the current filter constraints.
        """
        obj = self.clone()
        obj.add_annotation(Count('*'), alias='__count', is_summary=True)
>       number = obj.get_aggregation(using, ['__count'])['__count']

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1ce15840>
using = 'default', added_aggregate_names = ['__count']

    def get_aggregation(self, using, added_aggregate_names):
        """
        Return the dictionary with the values of the existing aggregations.
        """
        if not self.annotation_select:
            return {}
        existing_annotations = [
            annotation for alias, annotation
            in self.annotations.items()
            if alias not in added_aggregate_names
        ]
        # Decide if we need to use a subquery.
        #
        # Existing annotations would cause incorrect results as get_aggregation()
        # must produce just one result and thus must not use GROUP BY. But we
        # aren't smart enough to remove the existing annotations from the
        # query, so those would force us to use GROUP BY.
        #
        # If the query has limit or distinct, or uses set operations, then
        # those operations must be done in a subquery so that the query
        # aggregates on the limit and/or distinct results instead of applying
        # the distinct and limit after the aggregation.
        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or
                self.distinct or self.combinator):
            from django.db.models.sql.subqueries import AggregateQuery
            inner_query = self.clone()
            inner_query.subquery = True
            outer_query = AggregateQuery(self.model, inner_query)
            inner_query.select_for_update = False
            inner_query.select_related = False
            inner_query.set_annotation_mask(self.annotation_select)
            if not self.is_sliced and not self.distinct_fields:
                # Queries with distinct_fields need ordering and when a limit
                # is applied we must take the slice from the ordered query.
                # Otherwise no need for ordering.
                inner_query.clear_ordering(True)
            if not inner_query.distinct:
                # If the inner query uses default select and it has some
                # aggregate annotations, then we must make sure the inner
                # query is grouped by the main model's primary key. However,
                # clearing the select clause can alter results if distinct is
                # used.
                has_existing_aggregate_annotations = any(
                    annotation for annotation in existing_annotations
                    if getattr(annotation, 'contains_aggregate', True)
                )
                if inner_query.default_cols and has_existing_aggregate_annotations:
                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
                inner_query.default_cols = False
    
            relabels = {t: 'subquery' for t in inner_query.alias_map}
            relabels[None] = 'subquery'
            # Remove any aggregates marked for reduction from the subquery
            # and move them to the outer AggregateQuery.
            col_cnt = 0
            for alias, expression in list(inner_query.annotation_select.items()):
                annotation_select_mask = inner_query.annotation_select_mask
                if expression.is_summary:
                    expression, col_cnt = inner_query.rewrite_cols(expression, col_cnt)
                    outer_query.annotations[alias] = expression.relabeled_clone(relabels)
                    del inner_query.annotations[alias]
                    annotation_select_mask.remove(alias)
                # Make sure the annotation_select wont use cached results.
                inner_query.set_annotation_mask(inner_query.annotation_select_mask)
            if inner_query.select == () and not inner_query.default_cols and not inner_query.annotation_select_mask:
                # In case of Model.objects[0:3].count(), there would be no
                # field selected in the inner query, yet we must use a subquery.
                # So, make sure at least one field is selected.
                inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
        else:
            outer_query = self
            self.select = ()
            self.default_cols = False
            self.extra = {}
    
        outer_query.clear_ordering(True)
        outer_query.clear_limits()
        outer_query.select_for_update = False
        outer_query.select_related = False
        compiler = outer_query.get_compiler(using)
>       result = compiler.execute_sql(SINGLE)

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
result_type = 'single', chunked_fetch = False, chunk_size = 100

    def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
        """
        Run the query against the database and return the result(s). The
        return value is a single data item if result_type is SINGLE, or an
        iterator over the results if the result_type is MULTI.
    
        result_type is either MULTI (use fetchmany() to retrieve all rows),
        SINGLE (only retrieve a single row), or None. In this last case, the
        cursor is returned if any query is executed, since it's used by
        subclasses such as InsertQuery). It's possible, however, that no query
        is needed, as the filters describe an empty set. In that case, None is
        returned, to avoid any unnecessary database interaction.
        """
        result_type = result_type or NO_RESULTS
        try:
>           sql, params = self.as_sql()

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
with_limits = True, with_col_aliases = False

    def as_sql(self, with_limits=True, with_col_aliases=False):
        """
        Create the SQL for this query. Return the SQL string and list of
        parameters.
    
        If 'with_limits' is False, any limit/offset information is not included
        in the query.
        """
        refcounts_before = self.query.alias_refcount.copy()
        try:
            extra_select, order_by, group_by = self.pre_sql_setup()
            for_update_part = None
            # Is a LIMIT/OFFSET clause needed?
            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
            combinator = self.query.combinator
            features = self.connection.features
            if combinator:
                if not getattr(features, 'supports_select_{}'.format(combinator)):
                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
            else:
                distinct_fields, distinct_params = self.get_distinct()
                # This must come after 'select', 'ordering', and 'distinct'
                # (see docstring of get_from_clause() for details).
                from_, f_params = self.get_from_clause()
>               where, w_params = self.compile(self.where) if self.where is not None else ("", [])

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
node = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1ce486a0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1ce48af0>, <django.db.models.lookups.Exact object at 0x7ebc1ce48a00>)>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1ce486a0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1ce48af0>, <django.db.models.lookups.Exact object at 0x7ebc1ce48a00>)>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        """
        Return the SQL version of the where clause and the value to be
        substituted in. Return '', [] if this node matches everything,
        None, [] if this node is empty, and raise EmptyResultSet if this
        node can't match anything.
        """
        result = []
        result_params = []
        if self.connector == AND:
            full_needed, empty_needed = len(self.children), 1
        else:
            full_needed, empty_needed = 1, len(self.children)
    
        for child in self.children:
            try:
>               sql, params = compiler.compile(child)

venv/lib/python3.10/site-packages/django/db/models/sql/where.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
node = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1ce486a0>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1ce486a0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        if isinstance(self.lhs, MultiColSource):
            assert self.rhs_is_direct_value()
            self.rhs = get_normalized_value(self.rhs, self.lhs)
            from django.db.models.sql.where import AND, WhereNode
            root_constraint = WhereNode()
            for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs):
                lookup_class = target.get_lookup(self.lookup_name)
                root_constraint.add(
                    lookup_class(target.get_col(self.lhs.alias, source), val), AND)
            return root_constraint.as_sql(compiler, connection)
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/fields/related_lookups.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1ce486a0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        # Avoid comparison against direct rhs if lhs is a boolean value. That
        # turns "boolfield__exact=True" into "WHERE boolean_field" instead of
        # "WHERE boolean_field = True" when allowed.
        if (
            isinstance(self.rhs, bool) and
            getattr(self.lhs, 'conditional', False) and
            connection.ops.conditional_expression_supported_in_where_clause(self.lhs)
        ):
            lhs_sql, params = self.process_lhs(compiler, connection)
            template = '%s' if self.rhs else 'NOT %s'
            return template % lhs_sql, params
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1ce486a0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        lhs_sql, params = self.process_lhs(compiler, connection)
>       rhs_sql, rhs_params = self.process_rhs(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1ce486a0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1ce48490>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def process_rhs(self, compiler, connection):
        from django.db.models.sql.query import Query
        if isinstance(self.rhs, Query):
            if self.rhs.has_limit_one():
                if not self.rhs.has_select_fields:
                    self.rhs.clear_select_clause()
                    self.rhs.add_fields(['pk'])
            else:
>               raise ValueError(
                    'The QuerySet value for an exact lookup must be limited to '
                    'one result using slicing.'
                )
E               ValueError: The QuerySet value for an exact lookup must be limited to one result using slicing.

venv/lib/python3.10/site-packages/django/db/models/lookups.py:297: ValueError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7ebc1d248be0>
unpublished_posts_with_published_locations = [<Post: My Black Cause Allow Seek Exist>, <Post: Just Top Believe Support Say Most>, <Post: Use Feel Old Color Pretty Clear>]

    def test_unpublished(self, unpublished_posts_with_published_locations):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7ebc1d1c76a0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
__________________ TestContent.test_only_own_pubs_in_profile ___________________

self = <test_content.ProfilePostContentTester object at 0x7ebc1d0cbca0>
client = <django.test.client.Client object at 0x7ebc1d1fb9a0>
url = '/profile/kochtyrone/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d1fb9a0>
path = '/profile/kochtyrone/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d1fb9a0>
path = '/profile/kochtyrone/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d1fb9a0>, method = 'GET'
path = '/profile/kochtyrone/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/kochtyrone/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/kochtyrone/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d1fb9a0>
request = {'PATH_INFO': '/profile/kochtyrone/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=o4jm4y1lgbv9997vc2i2jm23vs47clrn', 'PATH_INFO': '/profile/kochtyrone/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': True, 'unicode_hint': '', 'frames': [{'exc_ca...connection):'], 'pre_context_lineno': 290}}]], 'templates': [<django.template.base.Template object at 0x7ebc1d0c8310>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7ebc1da58f70>, {'templates': [<django.template.base.Template...process_rhs(compiler, connection)', '', '    def as_sql(self, compiler, connection):'], 'pre_context_lineno': 290}}]]})
signal_uid = 'template-render-139346405810688'
exception_uid = 'request-exception-139346405810688'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1d1fb9a0>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kochtyrone/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7ebc1d1fb6d0>
request = <WSGIRequest: GET '/profile/kochtyrone/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kochtyrone/'>, args = ()
kwargs = {'name_slug': 'kochtyrone'}
self = <blog.views.ProfileListView object at 0x7ebc1d0c8ee0>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d0c8ee0>
request = <WSGIRequest: GET '/profile/kochtyrone/'>, args = ()
kwargs = {'name_slug': 'kochtyrone'}
handler = <bound method BaseListView.get of <blog.views.ProfileListView object at 0x7ebc1d0c8ee0>>

    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
>       return handler(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d0c8ee0>
request = <WSGIRequest: GET '/profile/kochtyrone/'>, args = ()
kwargs = {'name_slug': 'kochtyrone'}, allow_empty = True

    def get(self, request, *args, **kwargs):
        self.object_list = self.get_queryset()
        allow_empty = self.get_allow_empty()
    
        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if self.get_paginate_by(self.object_list) is not None and hasattr(self.object_list, 'exists'):
                is_empty = not self.object_list.exists()
            else:
                is_empty = not self.object_list
            if is_empty:
                raise Http404(_('Empty list and “%(class_name)s.allow_empty” is False.') % {
                    'class_name': self.__class__.__name__,
                })
>       context = self.get_context_data()

venv/lib/python3.10/site-packages/django/views/generic/list.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d0c8ee0>, kwargs = {}

    def get_context_data(self, **kwargs) -> dict:
        """Добавляет в контекст сведения о профиле пользователя."""
>       context: dict = super().get_context_data(**kwargs)

blogicum/blog/views.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d0c8ee0>, object_list = None
kwargs = {}
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1d0c93c0>
page_size = 10, context_object_name = 'post_list'

    def get_context_data(self, *, object_list=None, **kwargs):
        """Get the context for this view."""
        queryset = object_list if object_list is not None else self.object_list
        page_size = self.get_paginate_by(queryset)
        context_object_name = self.get_context_object_name(queryset)
        if page_size:
>           paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)

venv/lib/python3.10/site-packages/django/views/generic/list.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1d0c8ee0>
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1d0c93c0>
page_size = 10

    def paginate_queryset(self, queryset, page_size):
        """Paginate the queryset, if needed."""
        paginator = self.get_paginator(
            queryset, page_size, orphans=self.get_paginate_orphans(),
            allow_empty_first_page=self.get_allow_empty())
        page_kwarg = self.page_kwarg
        page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1
        try:
            page_number = int(page)
        except ValueError:
            if page == 'last':
                page_number = paginator.num_pages
            else:
                raise Http404(_('Page is not “last”, nor can it be converted to an int.'))
        try:
>           page = paginator.page(page_number)

venv/lib/python3.10/site-packages/django/views/generic/list.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d0cb0a0>, number = 1

    def page(self, number):
        """Return a Page object for the given 1-based page number."""
>       number = self.validate_number(number)

venv/lib/python3.10/site-packages/django/core/paginator.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d0cb0a0>, number = 1

    def validate_number(self, number):
        """Validate the given 1-based page number."""
        try:
            if isinstance(number, float) and not number.is_integer():
                raise ValueError
            number = int(number)
        except (TypeError, ValueError):
            raise PageNotAnInteger(_('That page number is not an integer'))
        if number < 1:
            raise EmptyPage(_('That page number is less than 1'))
>       if number > self.num_pages:

venv/lib/python3.10/site-packages/django/core/paginator.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28ddb0>
instance = <django.core.paginator.Paginator object at 0x7ebc1d0cb0a0>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d0cb0a0>

    @cached_property
    def num_pages(self):
        """Return the total number of pages."""
>       if self.count == 0 and not self.allow_empty_first_page:

venv/lib/python3.10/site-packages/django/core/paginator.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28dd50>
instance = <django.core.paginator.Paginator object at 0x7ebc1d0cb0a0>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d0cb0a0>

    @cached_property
    def count(self):
        """Return the total number of objects, across all pages."""
        c = getattr(self.object_list, 'count', None)
        if callable(c) and not inspect.isbuiltin(c) and method_has_no_args(c):
>           return c()

venv/lib/python3.10/site-packages/django/core/paginator.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1d0c93c0>

    def count(self):
        """
        Perform a SELECT COUNT() and return the number of records as an
        integer.
    
        If the QuerySet is already fully cached, return the length of the
        cached results set to avoid multiple SELECT COUNT(*) calls.
        """
        if self._result_cache is not None:
            return len(self._result_cache)
    
>       return self.query.get_count(using=self.db)

venv/lib/python3.10/site-packages/django/db/models/query.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1d0c8610>
using = 'default'

    def get_count(self, using):
        """
        Perform a COUNT() query using the current filter constraints.
        """
        obj = self.clone()
        obj.add_annotation(Count('*'), alias='__count', is_summary=True)
>       number = obj.get_aggregation(using, ['__count'])['__count']

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1d0c8e80>
using = 'default', added_aggregate_names = ['__count']

    def get_aggregation(self, using, added_aggregate_names):
        """
        Return the dictionary with the values of the existing aggregations.
        """
        if not self.annotation_select:
            return {}
        existing_annotations = [
            annotation for alias, annotation
            in self.annotations.items()
            if alias not in added_aggregate_names
        ]
        # Decide if we need to use a subquery.
        #
        # Existing annotations would cause incorrect results as get_aggregation()
        # must produce just one result and thus must not use GROUP BY. But we
        # aren't smart enough to remove the existing annotations from the
        # query, so those would force us to use GROUP BY.
        #
        # If the query has limit or distinct, or uses set operations, then
        # those operations must be done in a subquery so that the query
        # aggregates on the limit and/or distinct results instead of applying
        # the distinct and limit after the aggregation.
        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or
                self.distinct or self.combinator):
            from django.db.models.sql.subqueries import AggregateQuery
            inner_query = self.clone()
            inner_query.subquery = True
            outer_query = AggregateQuery(self.model, inner_query)
            inner_query.select_for_update = False
            inner_query.select_related = False
            inner_query.set_annotation_mask(self.annotation_select)
            if not self.is_sliced and not self.distinct_fields:
                # Queries with distinct_fields need ordering and when a limit
                # is applied we must take the slice from the ordered query.
                # Otherwise no need for ordering.
                inner_query.clear_ordering(True)
            if not inner_query.distinct:
                # If the inner query uses default select and it has some
                # aggregate annotations, then we must make sure the inner
                # query is grouped by the main model's primary key. However,
                # clearing the select clause can alter results if distinct is
                # used.
                has_existing_aggregate_annotations = any(
                    annotation for annotation in existing_annotations
                    if getattr(annotation, 'contains_aggregate', True)
                )
                if inner_query.default_cols and has_existing_aggregate_annotations:
                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
                inner_query.default_cols = False
    
            relabels = {t: 'subquery' for t in inner_query.alias_map}
            relabels[None] = 'subquery'
            # Remove any aggregates marked for reduction from the subquery
            # and move them to the outer AggregateQuery.
            col_cnt = 0
            for alias, expression in list(inner_query.annotation_select.items()):
                annotation_select_mask = inner_query.annotation_select_mask
                if expression.is_summary:
                    expression, col_cnt = inner_query.rewrite_cols(expression, col_cnt)
                    outer_query.annotations[alias] = expression.relabeled_clone(relabels)
                    del inner_query.annotations[alias]
                    annotation_select_mask.remove(alias)
                # Make sure the annotation_select wont use cached results.
                inner_query.set_annotation_mask(inner_query.annotation_select_mask)
            if inner_query.select == () and not inner_query.default_cols and not inner_query.annotation_select_mask:
                # In case of Model.objects[0:3].count(), there would be no
                # field selected in the inner query, yet we must use a subquery.
                # So, make sure at least one field is selected.
                inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
        else:
            outer_query = self
            self.select = ()
            self.default_cols = False
            self.extra = {}
    
        outer_query.clear_ordering(True)
        outer_query.clear_limits()
        outer_query.select_for_update = False
        outer_query.select_related = False
        compiler = outer_query.get_compiler(using)
>       result = compiler.execute_sql(SINGLE)

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
result_type = 'single', chunked_fetch = False, chunk_size = 100

    def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
        """
        Run the query against the database and return the result(s). The
        return value is a single data item if result_type is SINGLE, or an
        iterator over the results if the result_type is MULTI.
    
        result_type is either MULTI (use fetchmany() to retrieve all rows),
        SINGLE (only retrieve a single row), or None. In this last case, the
        cursor is returned if any query is executed, since it's used by
        subclasses such as InsertQuery). It's possible, however, that no query
        is needed, as the filters describe an empty set. In that case, None is
        returned, to avoid any unnecessary database interaction.
        """
        result_type = result_type or NO_RESULTS
        try:
>           sql, params = self.as_sql()

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
with_limits = True, with_col_aliases = False

    def as_sql(self, with_limits=True, with_col_aliases=False):
        """
        Create the SQL for this query. Return the SQL string and list of
        parameters.
    
        If 'with_limits' is False, any limit/offset information is not included
        in the query.
        """
        refcounts_before = self.query.alias_refcount.copy()
        try:
            extra_select, order_by, group_by = self.pre_sql_setup()
            for_update_part = None
            # Is a LIMIT/OFFSET clause needed?
            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
            combinator = self.query.combinator
            features = self.connection.features
            if combinator:
                if not getattr(features, 'supports_select_{}'.format(combinator)):
                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
            else:
                distinct_fields, distinct_params = self.get_distinct()
                # This must come after 'select', 'ordering', and 'distinct'
                # (see docstring of get_from_clause() for details).
                from_, f_params = self.get_from_clause()
>               where, w_params = self.compile(self.where) if self.where is not None else ("", [])

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
node = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1d0c8be0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1d0c97e0>, <django.db.models.lookups.Exact object at 0x7ebc1d0c8c70>)>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1d0c8be0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1d0c97e0>, <django.db.models.lookups.Exact object at 0x7ebc1d0c8c70>)>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        """
        Return the SQL version of the where clause and the value to be
        substituted in. Return '', [] if this node matches everything,
        None, [] if this node is empty, and raise EmptyResultSet if this
        node can't match anything.
        """
        result = []
        result_params = []
        if self.connector == AND:
            full_needed, empty_needed = len(self.children), 1
        else:
            full_needed, empty_needed = 1, len(self.children)
    
        for child in self.children:
            try:
>               sql, params = compiler.compile(child)

venv/lib/python3.10/site-packages/django/db/models/sql/where.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
node = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1d0c8be0>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1d0c8be0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        if isinstance(self.lhs, MultiColSource):
            assert self.rhs_is_direct_value()
            self.rhs = get_normalized_value(self.rhs, self.lhs)
            from django.db.models.sql.where import AND, WhereNode
            root_constraint = WhereNode()
            for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs):
                lookup_class = target.get_lookup(self.lookup_name)
                root_constraint.add(
                    lookup_class(target.get_col(self.lhs.alias, source), val), AND)
            return root_constraint.as_sql(compiler, connection)
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/fields/related_lookups.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1d0c8be0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        # Avoid comparison against direct rhs if lhs is a boolean value. That
        # turns "boolfield__exact=True" into "WHERE boolean_field" instead of
        # "WHERE boolean_field = True" when allowed.
        if (
            isinstance(self.rhs, bool) and
            getattr(self.lhs, 'conditional', False) and
            connection.ops.conditional_expression_supported_in_where_clause(self.lhs)
        ):
            lhs_sql, params = self.process_lhs(compiler, connection)
            template = '%s' if self.rhs else 'NOT %s'
            return template % lhs_sql, params
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1d0c8be0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        lhs_sql, params = self.process_lhs(compiler, connection)
>       rhs_sql, rhs_params = self.process_rhs(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1d0c8be0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1d0c8730>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def process_rhs(self, compiler, connection):
        from django.db.models.sql.query import Query
        if isinstance(self.rhs, Query):
            if self.rhs.has_limit_one():
                if not self.rhs.has_select_fields:
                    self.rhs.clear_select_clause()
                    self.rhs.add_fields(['pk'])
            else:
>               raise ValueError(
                    'The QuerySet value for an exact lookup must be limited to '
                    'one result using slicing.'
                )
E               ValueError: The QuerySet value for an exact lookup must be limited to one result using slicing.

venv/lib/python3.10/site-packages/django/db/models/lookups.py:297: ValueError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7ebc1d249270>
user_client = <django.test.client.Client object at 0x7ebc1d1fb9a0>
post_with_published_location = <Post: Happy Know Office Agency Experience Third>
post_of_another_author = <Post: Election Create Main Various Take Far>

    def test_only_own_pubs_in_profile(
            self, user_client, post_with_published_location,
            post_of_another_author
    ):
>       response = self.profile_tester.user_client_testget()

tests/test_content.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7ebc1d0cbca0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
____________________ TestContent.test_unpublished_category _____________________

self = <test_content.ProfilePostContentTester object at 0x7ebc1c845a50>
client = <django.test.client.Client object at 0x7ebc1c845f60>
url = '/profile/fernando82/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c845f60>
path = '/profile/fernando82/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c845f60>
path = '/profile/fernando82/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c845f60>, method = 'GET'
path = '/profile/fernando82/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/fernando82/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/fernando82/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c845f60>
request = {'PATH_INFO': '/profile/fernando82/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=ip61qkc61k7q5i1eq239oedkcb0whig1', 'PATH_INFO': '/profile/fernando82/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': True, 'unicode_hint': '', 'frames': [{'exc_ca...connection):'], 'pre_context_lineno': 290}}]], 'templates': [<django.template.base.Template object at 0x7ebc1ce33fd0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7ebc1da58f70>, {'templates': [<django.template.base.Template...process_rhs(compiler, connection)', '', '    def as_sql(self, compiler, connection):'], 'pre_context_lineno': 290}}]]})
signal_uid = 'template-render-139346398705024'
exception_uid = 'request-exception-139346398705024'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c845f60>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/fernando82/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7ebc1c846020>
request = <WSGIRequest: GET '/profile/fernando82/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/fernando82/'>, args = ()
kwargs = {'name_slug': 'fernando82'}
self = <blog.views.ProfileListView object at 0x7ebc1c844910>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c844910>
request = <WSGIRequest: GET '/profile/fernando82/'>, args = ()
kwargs = {'name_slug': 'fernando82'}
handler = <bound method BaseListView.get of <blog.views.ProfileListView object at 0x7ebc1c844910>>

    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
>       return handler(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c844910>
request = <WSGIRequest: GET '/profile/fernando82/'>, args = ()
kwargs = {'name_slug': 'fernando82'}, allow_empty = True

    def get(self, request, *args, **kwargs):
        self.object_list = self.get_queryset()
        allow_empty = self.get_allow_empty()
    
        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if self.get_paginate_by(self.object_list) is not None and hasattr(self.object_list, 'exists'):
                is_empty = not self.object_list.exists()
            else:
                is_empty = not self.object_list
            if is_empty:
                raise Http404(_('Empty list and “%(class_name)s.allow_empty” is False.') % {
                    'class_name': self.__class__.__name__,
                })
>       context = self.get_context_data()

venv/lib/python3.10/site-packages/django/views/generic/list.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c844910>, kwargs = {}

    def get_context_data(self, **kwargs) -> dict:
        """Добавляет в контекст сведения о профиле пользователя."""
>       context: dict = super().get_context_data(**kwargs)

blogicum/blog/views.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c844910>, object_list = None
kwargs = {}
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c844c40>
page_size = 10, context_object_name = 'post_list'

    def get_context_data(self, *, object_list=None, **kwargs):
        """Get the context for this view."""
        queryset = object_list if object_list is not None else self.object_list
        page_size = self.get_paginate_by(queryset)
        context_object_name = self.get_context_object_name(queryset)
        if page_size:
>           paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)

venv/lib/python3.10/site-packages/django/views/generic/list.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c844910>
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c844c40>
page_size = 10

    def paginate_queryset(self, queryset, page_size):
        """Paginate the queryset, if needed."""
        paginator = self.get_paginator(
            queryset, page_size, orphans=self.get_paginate_orphans(),
            allow_empty_first_page=self.get_allow_empty())
        page_kwarg = self.page_kwarg
        page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1
        try:
            page_number = int(page)
        except ValueError:
            if page == 'last':
                page_number = paginator.num_pages
            else:
                raise Http404(_('Page is not “last”, nor can it be converted to an int.'))
        try:
>           page = paginator.page(page_number)

venv/lib/python3.10/site-packages/django/views/generic/list.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c8447c0>, number = 1

    def page(self, number):
        """Return a Page object for the given 1-based page number."""
>       number = self.validate_number(number)

venv/lib/python3.10/site-packages/django/core/paginator.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c8447c0>, number = 1

    def validate_number(self, number):
        """Validate the given 1-based page number."""
        try:
            if isinstance(number, float) and not number.is_integer():
                raise ValueError
            number = int(number)
        except (TypeError, ValueError):
            raise PageNotAnInteger(_('That page number is not an integer'))
        if number < 1:
            raise EmptyPage(_('That page number is less than 1'))
>       if number > self.num_pages:

venv/lib/python3.10/site-packages/django/core/paginator.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28ddb0>
instance = <django.core.paginator.Paginator object at 0x7ebc1c8447c0>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c8447c0>

    @cached_property
    def num_pages(self):
        """Return the total number of pages."""
>       if self.count == 0 and not self.allow_empty_first_page:

venv/lib/python3.10/site-packages/django/core/paginator.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28dd50>
instance = <django.core.paginator.Paginator object at 0x7ebc1c8447c0>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c8447c0>

    @cached_property
    def count(self):
        """Return the total number of objects, across all pages."""
        c = getattr(self.object_list, 'count', None)
        if callable(c) and not inspect.isbuiltin(c) and method_has_no_args(c):
>           return c()

venv/lib/python3.10/site-packages/django/core/paginator.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c844c40>

    def count(self):
        """
        Perform a SELECT COUNT() and return the number of records as an
        integer.
    
        If the QuerySet is already fully cached, return the length of the
        cached results set to avoid multiple SELECT COUNT(*) calls.
        """
        if self._result_cache is not None:
            return len(self._result_cache)
    
>       return self.query.get_count(using=self.db)

venv/lib/python3.10/site-packages/django/db/models/query.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1c844040>
using = 'default'

    def get_count(self, using):
        """
        Perform a COUNT() query using the current filter constraints.
        """
        obj = self.clone()
        obj.add_annotation(Count('*'), alias='__count', is_summary=True)
>       number = obj.get_aggregation(using, ['__count'])['__count']

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1c8447f0>
using = 'default', added_aggregate_names = ['__count']

    def get_aggregation(self, using, added_aggregate_names):
        """
        Return the dictionary with the values of the existing aggregations.
        """
        if not self.annotation_select:
            return {}
        existing_annotations = [
            annotation for alias, annotation
            in self.annotations.items()
            if alias not in added_aggregate_names
        ]
        # Decide if we need to use a subquery.
        #
        # Existing annotations would cause incorrect results as get_aggregation()
        # must produce just one result and thus must not use GROUP BY. But we
        # aren't smart enough to remove the existing annotations from the
        # query, so those would force us to use GROUP BY.
        #
        # If the query has limit or distinct, or uses set operations, then
        # those operations must be done in a subquery so that the query
        # aggregates on the limit and/or distinct results instead of applying
        # the distinct and limit after the aggregation.
        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or
                self.distinct or self.combinator):
            from django.db.models.sql.subqueries import AggregateQuery
            inner_query = self.clone()
            inner_query.subquery = True
            outer_query = AggregateQuery(self.model, inner_query)
            inner_query.select_for_update = False
            inner_query.select_related = False
            inner_query.set_annotation_mask(self.annotation_select)
            if not self.is_sliced and not self.distinct_fields:
                # Queries with distinct_fields need ordering and when a limit
                # is applied we must take the slice from the ordered query.
                # Otherwise no need for ordering.
                inner_query.clear_ordering(True)
            if not inner_query.distinct:
                # If the inner query uses default select and it has some
                # aggregate annotations, then we must make sure the inner
                # query is grouped by the main model's primary key. However,
                # clearing the select clause can alter results if distinct is
                # used.
                has_existing_aggregate_annotations = any(
                    annotation for annotation in existing_annotations
                    if getattr(annotation, 'contains_aggregate', True)
                )
                if inner_query.default_cols and has_existing_aggregate_annotations:
                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
                inner_query.default_cols = False
    
            relabels = {t: 'subquery' for t in inner_query.alias_map}
            relabels[None] = 'subquery'
            # Remove any aggregates marked for reduction from the subquery
            # and move them to the outer AggregateQuery.
            col_cnt = 0
            for alias, expression in list(inner_query.annotation_select.items()):
                annotation_select_mask = inner_query.annotation_select_mask
                if expression.is_summary:
                    expression, col_cnt = inner_query.rewrite_cols(expression, col_cnt)
                    outer_query.annotations[alias] = expression.relabeled_clone(relabels)
                    del inner_query.annotations[alias]
                    annotation_select_mask.remove(alias)
                # Make sure the annotation_select wont use cached results.
                inner_query.set_annotation_mask(inner_query.annotation_select_mask)
            if inner_query.select == () and not inner_query.default_cols and not inner_query.annotation_select_mask:
                # In case of Model.objects[0:3].count(), there would be no
                # field selected in the inner query, yet we must use a subquery.
                # So, make sure at least one field is selected.
                inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
        else:
            outer_query = self
            self.select = ()
            self.default_cols = False
            self.extra = {}
    
        outer_query.clear_ordering(True)
        outer_query.clear_limits()
        outer_query.select_for_update = False
        outer_query.select_related = False
        compiler = outer_query.get_compiler(using)
>       result = compiler.execute_sql(SINGLE)

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
result_type = 'single', chunked_fetch = False, chunk_size = 100

    def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
        """
        Run the query against the database and return the result(s). The
        return value is a single data item if result_type is SINGLE, or an
        iterator over the results if the result_type is MULTI.
    
        result_type is either MULTI (use fetchmany() to retrieve all rows),
        SINGLE (only retrieve a single row), or None. In this last case, the
        cursor is returned if any query is executed, since it's used by
        subclasses such as InsertQuery). It's possible, however, that no query
        is needed, as the filters describe an empty set. In that case, None is
        returned, to avoid any unnecessary database interaction.
        """
        result_type = result_type or NO_RESULTS
        try:
>           sql, params = self.as_sql()

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
with_limits = True, with_col_aliases = False

    def as_sql(self, with_limits=True, with_col_aliases=False):
        """
        Create the SQL for this query. Return the SQL string and list of
        parameters.
    
        If 'with_limits' is False, any limit/offset information is not included
        in the query.
        """
        refcounts_before = self.query.alias_refcount.copy()
        try:
            extra_select, order_by, group_by = self.pre_sql_setup()
            for_update_part = None
            # Is a LIMIT/OFFSET clause needed?
            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
            combinator = self.query.combinator
            features = self.connection.features
            if combinator:
                if not getattr(features, 'supports_select_{}'.format(combinator)):
                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
            else:
                distinct_fields, distinct_params = self.get_distinct()
                # This must come after 'select', 'ordering', and 'distinct'
                # (see docstring of get_from_clause() for details).
                from_, f_params = self.get_from_clause()
>               where, w_params = self.compile(self.where) if self.where is not None else ("", [])

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
node = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c844070>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1d12d720>, <django.db.models.lookups.Exact object at 0x7ebc1d12ef20>)>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c844070>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1d12d720>, <django.db.models.lookups.Exact object at 0x7ebc1d12ef20>)>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        """
        Return the SQL version of the where clause and the value to be
        substituted in. Return '', [] if this node matches everything,
        None, [] if this node is empty, and raise EmptyResultSet if this
        node can't match anything.
        """
        result = []
        result_params = []
        if self.connector == AND:
            full_needed, empty_needed = len(self.children), 1
        else:
            full_needed, empty_needed = 1, len(self.children)
    
        for child in self.children:
            try:
>               sql, params = compiler.compile(child)

venv/lib/python3.10/site-packages/django/db/models/sql/where.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
node = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c844070>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c844070>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        if isinstance(self.lhs, MultiColSource):
            assert self.rhs_is_direct_value()
            self.rhs = get_normalized_value(self.rhs, self.lhs)
            from django.db.models.sql.where import AND, WhereNode
            root_constraint = WhereNode()
            for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs):
                lookup_class = target.get_lookup(self.lookup_name)
                root_constraint.add(
                    lookup_class(target.get_col(self.lhs.alias, source), val), AND)
            return root_constraint.as_sql(compiler, connection)
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/fields/related_lookups.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c844070>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        # Avoid comparison against direct rhs if lhs is a boolean value. That
        # turns "boolfield__exact=True" into "WHERE boolean_field" instead of
        # "WHERE boolean_field = True" when allowed.
        if (
            isinstance(self.rhs, bool) and
            getattr(self.lhs, 'conditional', False) and
            connection.ops.conditional_expression_supported_in_where_clause(self.lhs)
        ):
            lhs_sql, params = self.process_lhs(compiler, connection)
            template = '%s' if self.rhs else 'NOT %s'
            return template % lhs_sql, params
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c844070>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        lhs_sql, params = self.process_lhs(compiler, connection)
>       rhs_sql, rhs_params = self.process_rhs(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c844070>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c844460>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def process_rhs(self, compiler, connection):
        from django.db.models.sql.query import Query
        if isinstance(self.rhs, Query):
            if self.rhs.has_limit_one():
                if not self.rhs.has_select_fields:
                    self.rhs.clear_select_clause()
                    self.rhs.add_fields(['pk'])
            else:
>               raise ValueError(
                    'The QuerySet value for an exact lookup must be limited to '
                    'one result using slicing.'
                )
E               ValueError: The QuerySet value for an exact lookup must be limited to one result using slicing.

venv/lib/python3.10/site-packages/django/db/models/lookups.py:297: ValueError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7ebc1d27f9a0>
user_client = <django.test.client.Client object at 0x7ebc1c845f60>
posts_with_unpublished_category = [<Post: Agent Relationship Field Baby Question Within>, <Post: Data Former One Machine Actually After>, <Post: Then Image Budget Blue People Might>]

    def test_unpublished_category(
        self, user_client, posts_with_unpublished_category
    ):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7ebc1c845a50>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_future_posts _________________________

self = <test_content.ProfilePostContentTester object at 0x7ebc1c469600>
client = <django.test.client.Client object at 0x7ebc1c4698d0>
url = '/profile/debralee/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c4698d0>
path = '/profile/debralee/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c4698d0>
path = '/profile/debralee/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c4698d0>, method = 'GET'
path = '/profile/debralee/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/debralee/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/debralee/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c4698d0>
request = {'PATH_INFO': '/profile/debralee/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=v4oupu9isz3t96e2761kya1mdcagixhy', 'PATH_INFO': '/profile/debralee/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': True, 'unicode_hint': '', 'frames': [{'exc_ca...connection):'], 'pre_context_lineno': 290}}]], 'templates': [<django.template.base.Template object at 0x7ebc1c8469b0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7ebc1da58f70>, {'templates': [<django.template.base.Template...process_rhs(compiler, connection)', '', '    def as_sql(self, compiler, connection):'], 'pre_context_lineno': 290}}]]})
signal_uid = 'template-render-139346398514560'
exception_uid = 'request-exception-139346398514560'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c4698d0>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/debralee/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7ebc1c4699f0>
request = <WSGIRequest: GET '/profile/debralee/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/debralee/'>, args = ()
kwargs = {'name_slug': 'debralee'}
self = <blog.views.ProfileListView object at 0x7ebc1c4680d0>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c4680d0>
request = <WSGIRequest: GET '/profile/debralee/'>, args = ()
kwargs = {'name_slug': 'debralee'}
handler = <bound method BaseListView.get of <blog.views.ProfileListView object at 0x7ebc1c4680d0>>

    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
>       return handler(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c4680d0>
request = <WSGIRequest: GET '/profile/debralee/'>, args = ()
kwargs = {'name_slug': 'debralee'}, allow_empty = True

    def get(self, request, *args, **kwargs):
        self.object_list = self.get_queryset()
        allow_empty = self.get_allow_empty()
    
        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if self.get_paginate_by(self.object_list) is not None and hasattr(self.object_list, 'exists'):
                is_empty = not self.object_list.exists()
            else:
                is_empty = not self.object_list
            if is_empty:
                raise Http404(_('Empty list and “%(class_name)s.allow_empty” is False.') % {
                    'class_name': self.__class__.__name__,
                })
>       context = self.get_context_data()

venv/lib/python3.10/site-packages/django/views/generic/list.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c4680d0>, kwargs = {}

    def get_context_data(self, **kwargs) -> dict:
        """Добавляет в контекст сведения о профиле пользователя."""
>       context: dict = super().get_context_data(**kwargs)

blogicum/blog/views.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c4680d0>, object_list = None
kwargs = {}
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c46bee0>
page_size = 10, context_object_name = 'post_list'

    def get_context_data(self, *, object_list=None, **kwargs):
        """Get the context for this view."""
        queryset = object_list if object_list is not None else self.object_list
        page_size = self.get_paginate_by(queryset)
        context_object_name = self.get_context_object_name(queryset)
        if page_size:
>           paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)

venv/lib/python3.10/site-packages/django/views/generic/list.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c4680d0>
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c46bee0>
page_size = 10

    def paginate_queryset(self, queryset, page_size):
        """Paginate the queryset, if needed."""
        paginator = self.get_paginator(
            queryset, page_size, orphans=self.get_paginate_orphans(),
            allow_empty_first_page=self.get_allow_empty())
        page_kwarg = self.page_kwarg
        page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1
        try:
            page_number = int(page)
        except ValueError:
            if page == 'last':
                page_number = paginator.num_pages
            else:
                raise Http404(_('Page is not “last”, nor can it be converted to an int.'))
        try:
>           page = paginator.page(page_number)

venv/lib/python3.10/site-packages/django/views/generic/list.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c46bfa0>, number = 1

    def page(self, number):
        """Return a Page object for the given 1-based page number."""
>       number = self.validate_number(number)

venv/lib/python3.10/site-packages/django/core/paginator.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c46bfa0>, number = 1

    def validate_number(self, number):
        """Validate the given 1-based page number."""
        try:
            if isinstance(number, float) and not number.is_integer():
                raise ValueError
            number = int(number)
        except (TypeError, ValueError):
            raise PageNotAnInteger(_('That page number is not an integer'))
        if number < 1:
            raise EmptyPage(_('That page number is less than 1'))
>       if number > self.num_pages:

venv/lib/python3.10/site-packages/django/core/paginator.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28ddb0>
instance = <django.core.paginator.Paginator object at 0x7ebc1c46bfa0>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c46bfa0>

    @cached_property
    def num_pages(self):
        """Return the total number of pages."""
>       if self.count == 0 and not self.allow_empty_first_page:

venv/lib/python3.10/site-packages/django/core/paginator.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28dd50>
instance = <django.core.paginator.Paginator object at 0x7ebc1c46bfa0>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c46bfa0>

    @cached_property
    def count(self):
        """Return the total number of objects, across all pages."""
        c = getattr(self.object_list, 'count', None)
        if callable(c) and not inspect.isbuiltin(c) and method_has_no_args(c):
>           return c()

venv/lib/python3.10/site-packages/django/core/paginator.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c46bee0>

    def count(self):
        """
        Perform a SELECT COUNT() and return the number of records as an
        integer.
    
        If the QuerySet is already fully cached, return the length of the
        cached results set to avoid multiple SELECT COUNT(*) calls.
        """
        if self._result_cache is not None:
            return len(self._result_cache)
    
>       return self.query.get_count(using=self.db)

venv/lib/python3.10/site-packages/django/db/models/query.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1d2019f0>
using = 'default'

    def get_count(self, using):
        """
        Perform a COUNT() query using the current filter constraints.
        """
        obj = self.clone()
        obj.add_annotation(Count('*'), alias='__count', is_summary=True)
>       number = obj.get_aggregation(using, ['__count'])['__count']

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1c468370>
using = 'default', added_aggregate_names = ['__count']

    def get_aggregation(self, using, added_aggregate_names):
        """
        Return the dictionary with the values of the existing aggregations.
        """
        if not self.annotation_select:
            return {}
        existing_annotations = [
            annotation for alias, annotation
            in self.annotations.items()
            if alias not in added_aggregate_names
        ]
        # Decide if we need to use a subquery.
        #
        # Existing annotations would cause incorrect results as get_aggregation()
        # must produce just one result and thus must not use GROUP BY. But we
        # aren't smart enough to remove the existing annotations from the
        # query, so those would force us to use GROUP BY.
        #
        # If the query has limit or distinct, or uses set operations, then
        # those operations must be done in a subquery so that the query
        # aggregates on the limit and/or distinct results instead of applying
        # the distinct and limit after the aggregation.
        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or
                self.distinct or self.combinator):
            from django.db.models.sql.subqueries import AggregateQuery
            inner_query = self.clone()
            inner_query.subquery = True
            outer_query = AggregateQuery(self.model, inner_query)
            inner_query.select_for_update = False
            inner_query.select_related = False
            inner_query.set_annotation_mask(self.annotation_select)
            if not self.is_sliced and not self.distinct_fields:
                # Queries with distinct_fields need ordering and when a limit
                # is applied we must take the slice from the ordered query.
                # Otherwise no need for ordering.
                inner_query.clear_ordering(True)
            if not inner_query.distinct:
                # If the inner query uses default select and it has some
                # aggregate annotations, then we must make sure the inner
                # query is grouped by the main model's primary key. However,
                # clearing the select clause can alter results if distinct is
                # used.
                has_existing_aggregate_annotations = any(
                    annotation for annotation in existing_annotations
                    if getattr(annotation, 'contains_aggregate', True)
                )
                if inner_query.default_cols and has_existing_aggregate_annotations:
                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
                inner_query.default_cols = False
    
            relabels = {t: 'subquery' for t in inner_query.alias_map}
            relabels[None] = 'subquery'
            # Remove any aggregates marked for reduction from the subquery
            # and move them to the outer AggregateQuery.
            col_cnt = 0
            for alias, expression in list(inner_query.annotation_select.items()):
                annotation_select_mask = inner_query.annotation_select_mask
                if expression.is_summary:
                    expression, col_cnt = inner_query.rewrite_cols(expression, col_cnt)
                    outer_query.annotations[alias] = expression.relabeled_clone(relabels)
                    del inner_query.annotations[alias]
                    annotation_select_mask.remove(alias)
                # Make sure the annotation_select wont use cached results.
                inner_query.set_annotation_mask(inner_query.annotation_select_mask)
            if inner_query.select == () and not inner_query.default_cols and not inner_query.annotation_select_mask:
                # In case of Model.objects[0:3].count(), there would be no
                # field selected in the inner query, yet we must use a subquery.
                # So, make sure at least one field is selected.
                inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
        else:
            outer_query = self
            self.select = ()
            self.default_cols = False
            self.extra = {}
    
        outer_query.clear_ordering(True)
        outer_query.clear_limits()
        outer_query.select_for_update = False
        outer_query.select_related = False
        compiler = outer_query.get_compiler(using)
>       result = compiler.execute_sql(SINGLE)

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
result_type = 'single', chunked_fetch = False, chunk_size = 100

    def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
        """
        Run the query against the database and return the result(s). The
        return value is a single data item if result_type is SINGLE, or an
        iterator over the results if the result_type is MULTI.
    
        result_type is either MULTI (use fetchmany() to retrieve all rows),
        SINGLE (only retrieve a single row), or None. In this last case, the
        cursor is returned if any query is executed, since it's used by
        subclasses such as InsertQuery). It's possible, however, that no query
        is needed, as the filters describe an empty set. In that case, None is
        returned, to avoid any unnecessary database interaction.
        """
        result_type = result_type or NO_RESULTS
        try:
>           sql, params = self.as_sql()

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
with_limits = True, with_col_aliases = False

    def as_sql(self, with_limits=True, with_col_aliases=False):
        """
        Create the SQL for this query. Return the SQL string and list of
        parameters.
    
        If 'with_limits' is False, any limit/offset information is not included
        in the query.
        """
        refcounts_before = self.query.alias_refcount.copy()
        try:
            extra_select, order_by, group_by = self.pre_sql_setup()
            for_update_part = None
            # Is a LIMIT/OFFSET clause needed?
            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
            combinator = self.query.combinator
            features = self.connection.features
            if combinator:
                if not getattr(features, 'supports_select_{}'.format(combinator)):
                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
            else:
                distinct_fields, distinct_params = self.get_distinct()
                # This must come after 'select', 'ordering', and 'distinct'
                # (see docstring of get_from_clause() for details).
                from_, f_params = self.get_from_clause()
>               where, w_params = self.compile(self.where) if self.where is not None else ("", [])

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
node = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c46bcd0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1c846680>, <django.db.models.lookups.Exact object at 0x7ebc1c847580>)>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c46bcd0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1c846680>, <django.db.models.lookups.Exact object at 0x7ebc1c847580>)>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        """
        Return the SQL version of the where clause and the value to be
        substituted in. Return '', [] if this node matches everything,
        None, [] if this node is empty, and raise EmptyResultSet if this
        node can't match anything.
        """
        result = []
        result_params = []
        if self.connector == AND:
            full_needed, empty_needed = len(self.children), 1
        else:
            full_needed, empty_needed = 1, len(self.children)
    
        for child in self.children:
            try:
>               sql, params = compiler.compile(child)

venv/lib/python3.10/site-packages/django/db/models/sql/where.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
node = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c46bcd0>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c46bcd0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        if isinstance(self.lhs, MultiColSource):
            assert self.rhs_is_direct_value()
            self.rhs = get_normalized_value(self.rhs, self.lhs)
            from django.db.models.sql.where import AND, WhereNode
            root_constraint = WhereNode()
            for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs):
                lookup_class = target.get_lookup(self.lookup_name)
                root_constraint.add(
                    lookup_class(target.get_col(self.lhs.alias, source), val), AND)
            return root_constraint.as_sql(compiler, connection)
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/fields/related_lookups.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c46bcd0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        # Avoid comparison against direct rhs if lhs is a boolean value. That
        # turns "boolfield__exact=True" into "WHERE boolean_field" instead of
        # "WHERE boolean_field = True" when allowed.
        if (
            isinstance(self.rhs, bool) and
            getattr(self.lhs, 'conditional', False) and
            connection.ops.conditional_expression_supported_in_where_clause(self.lhs)
        ):
            lhs_sql, params = self.process_lhs(compiler, connection)
            template = '%s' if self.rhs else 'NOT %s'
            return template % lhs_sql, params
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c46bcd0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        lhs_sql, params = self.process_lhs(compiler, connection)
>       rhs_sql, rhs_params = self.process_rhs(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c46bcd0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c46ba00>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def process_rhs(self, compiler, connection):
        from django.db.models.sql.query import Query
        if isinstance(self.rhs, Query):
            if self.rhs.has_limit_one():
                if not self.rhs.has_select_fields:
                    self.rhs.clear_select_clause()
                    self.rhs.add_fields(['pk'])
            else:
>               raise ValueError(
                    'The QuerySet value for an exact lookup must be limited to '
                    'one result using slicing.'
                )
E               ValueError: The QuerySet value for an exact lookup must be limited to one result using slicing.

venv/lib/python3.10/site-packages/django/db/models/lookups.py:297: ValueError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7ebc1d248bb0>
user_client = <django.test.client.Client object at 0x7ebc1c4698d0>
future_posts = [<Post: Memory Degree Floor Particular Tonight Blood>, <Post: Base Believe Ground Interview Once For>, <Post: History Different Wish Information Culture Out>]

    def test_future_posts(self, user_client, future_posts):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:441: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7ebc1c469600>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
_________________________ TestContent.test_pagination __________________________

self = <test_content.ProfilePostContentTester object at 0x7ebc1c376b00>
client = <django.test.client.Client object at 0x7ebc1c377130>
url = '/profile/markcortez/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c377130>
path = '/profile/markcortez/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c377130>
path = '/profile/markcortez/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c377130>, method = 'GET'
path = '/profile/markcortez/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/markcortez/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/markcortez/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c377130>
request = {'PATH_INFO': '/profile/markcortez/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=vb70gqsci64knelz2ulvjf3owkxrpjzd', 'PATH_INFO': '/profile/markcortez/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': True, 'unicode_hint': '', 'frames': [{'exc_ca...connection):'], 'pre_context_lineno': 290}}]], 'templates': [<django.template.base.Template object at 0x7ebc1c4699c0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7ebc1da58f70>, {'templates': [<django.template.base.Template...process_rhs(compiler, connection)', '', '    def as_sql(self, compiler, connection):'], 'pre_context_lineno': 290}}]]})
signal_uid = 'template-render-139346398763328'
exception_uid = 'request-exception-139346398763328'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c377130>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/markcortez/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7ebc1c377010>
request = <WSGIRequest: GET '/profile/markcortez/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/markcortez/'>, args = ()
kwargs = {'name_slug': 'markcortez'}
self = <blog.views.ProfileListView object at 0x7ebc1c374370>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c374370>
request = <WSGIRequest: GET '/profile/markcortez/'>, args = ()
kwargs = {'name_slug': 'markcortez'}
handler = <bound method BaseListView.get of <blog.views.ProfileListView object at 0x7ebc1c374370>>

    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
>       return handler(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c374370>
request = <WSGIRequest: GET '/profile/markcortez/'>, args = ()
kwargs = {'name_slug': 'markcortez'}, allow_empty = True

    def get(self, request, *args, **kwargs):
        self.object_list = self.get_queryset()
        allow_empty = self.get_allow_empty()
    
        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if self.get_paginate_by(self.object_list) is not None and hasattr(self.object_list, 'exists'):
                is_empty = not self.object_list.exists()
            else:
                is_empty = not self.object_list
            if is_empty:
                raise Http404(_('Empty list and “%(class_name)s.allow_empty” is False.') % {
                    'class_name': self.__class__.__name__,
                })
>       context = self.get_context_data()

venv/lib/python3.10/site-packages/django/views/generic/list.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c374370>, kwargs = {}

    def get_context_data(self, **kwargs) -> dict:
        """Добавляет в контекст сведения о профиле пользователя."""
>       context: dict = super().get_context_data(**kwargs)

blogicum/blog/views.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c374370>, object_list = None
kwargs = {}
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1ce150c0>
page_size = 10, context_object_name = 'post_list'

    def get_context_data(self, *, object_list=None, **kwargs):
        """Get the context for this view."""
        queryset = object_list if object_list is not None else self.object_list
        page_size = self.get_paginate_by(queryset)
        context_object_name = self.get_context_object_name(queryset)
        if page_size:
>           paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)

venv/lib/python3.10/site-packages/django/views/generic/list.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c374370>
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1ce150c0>
page_size = 10

    def paginate_queryset(self, queryset, page_size):
        """Paginate the queryset, if needed."""
        paginator = self.get_paginator(
            queryset, page_size, orphans=self.get_paginate_orphans(),
            allow_empty_first_page=self.get_allow_empty())
        page_kwarg = self.page_kwarg
        page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1
        try:
            page_number = int(page)
        except ValueError:
            if page == 'last':
                page_number = paginator.num_pages
            else:
                raise Http404(_('Page is not “last”, nor can it be converted to an int.'))
        try:
>           page = paginator.page(page_number)

venv/lib/python3.10/site-packages/django/views/generic/list.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d2c1b40>, number = 1

    def page(self, number):
        """Return a Page object for the given 1-based page number."""
>       number = self.validate_number(number)

venv/lib/python3.10/site-packages/django/core/paginator.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d2c1b40>, number = 1

    def validate_number(self, number):
        """Validate the given 1-based page number."""
        try:
            if isinstance(number, float) and not number.is_integer():
                raise ValueError
            number = int(number)
        except (TypeError, ValueError):
            raise PageNotAnInteger(_('That page number is not an integer'))
        if number < 1:
            raise EmptyPage(_('That page number is less than 1'))
>       if number > self.num_pages:

venv/lib/python3.10/site-packages/django/core/paginator.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28ddb0>
instance = <django.core.paginator.Paginator object at 0x7ebc1d2c1b40>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d2c1b40>

    @cached_property
    def num_pages(self):
        """Return the total number of pages."""
>       if self.count == 0 and not self.allow_empty_first_page:

venv/lib/python3.10/site-packages/django/core/paginator.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28dd50>
instance = <django.core.paginator.Paginator object at 0x7ebc1d2c1b40>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1d2c1b40>

    @cached_property
    def count(self):
        """Return the total number of objects, across all pages."""
        c = getattr(self.object_list, 'count', None)
        if callable(c) and not inspect.isbuiltin(c) and method_has_no_args(c):
>           return c()

venv/lib/python3.10/site-packages/django/core/paginator.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1ce150c0>

    def count(self):
        """
        Perform a SELECT COUNT() and return the number of records as an
        integer.
    
        If the QuerySet is already fully cached, return the length of the
        cached results set to avoid multiple SELECT COUNT(*) calls.
        """
        if self._result_cache is not None:
            return len(self._result_cache)
    
>       return self.query.get_count(using=self.db)

venv/lib/python3.10/site-packages/django/db/models/query.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1c518d30>
using = 'default'

    def get_count(self, using):
        """
        Perform a COUNT() query using the current filter constraints.
        """
        obj = self.clone()
        obj.add_annotation(Count('*'), alias='__count', is_summary=True)
>       number = obj.get_aggregation(using, ['__count'])['__count']

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1c519450>
using = 'default', added_aggregate_names = ['__count']

    def get_aggregation(self, using, added_aggregate_names):
        """
        Return the dictionary with the values of the existing aggregations.
        """
        if not self.annotation_select:
            return {}
        existing_annotations = [
            annotation for alias, annotation
            in self.annotations.items()
            if alias not in added_aggregate_names
        ]
        # Decide if we need to use a subquery.
        #
        # Existing annotations would cause incorrect results as get_aggregation()
        # must produce just one result and thus must not use GROUP BY. But we
        # aren't smart enough to remove the existing annotations from the
        # query, so those would force us to use GROUP BY.
        #
        # If the query has limit or distinct, or uses set operations, then
        # those operations must be done in a subquery so that the query
        # aggregates on the limit and/or distinct results instead of applying
        # the distinct and limit after the aggregation.
        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or
                self.distinct or self.combinator):
            from django.db.models.sql.subqueries import AggregateQuery
            inner_query = self.clone()
            inner_query.subquery = True
            outer_query = AggregateQuery(self.model, inner_query)
            inner_query.select_for_update = False
            inner_query.select_related = False
            inner_query.set_annotation_mask(self.annotation_select)
            if not self.is_sliced and not self.distinct_fields:
                # Queries with distinct_fields need ordering and when a limit
                # is applied we must take the slice from the ordered query.
                # Otherwise no need for ordering.
                inner_query.clear_ordering(True)
            if not inner_query.distinct:
                # If the inner query uses default select and it has some
                # aggregate annotations, then we must make sure the inner
                # query is grouped by the main model's primary key. However,
                # clearing the select clause can alter results if distinct is
                # used.
                has_existing_aggregate_annotations = any(
                    annotation for annotation in existing_annotations
                    if getattr(annotation, 'contains_aggregate', True)
                )
                if inner_query.default_cols and has_existing_aggregate_annotations:
                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
                inner_query.default_cols = False
    
            relabels = {t: 'subquery' for t in inner_query.alias_map}
            relabels[None] = 'subquery'
            # Remove any aggregates marked for reduction from the subquery
            # and move them to the outer AggregateQuery.
            col_cnt = 0
            for alias, expression in list(inner_query.annotation_select.items()):
                annotation_select_mask = inner_query.annotation_select_mask
                if expression.is_summary:
                    expression, col_cnt = inner_query.rewrite_cols(expression, col_cnt)
                    outer_query.annotations[alias] = expression.relabeled_clone(relabels)
                    del inner_query.annotations[alias]
                    annotation_select_mask.remove(alias)
                # Make sure the annotation_select wont use cached results.
                inner_query.set_annotation_mask(inner_query.annotation_select_mask)
            if inner_query.select == () and not inner_query.default_cols and not inner_query.annotation_select_mask:
                # In case of Model.objects[0:3].count(), there would be no
                # field selected in the inner query, yet we must use a subquery.
                # So, make sure at least one field is selected.
                inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
        else:
            outer_query = self
            self.select = ()
            self.default_cols = False
            self.extra = {}
    
        outer_query.clear_ordering(True)
        outer_query.clear_limits()
        outer_query.select_for_update = False
        outer_query.select_related = False
        compiler = outer_query.get_compiler(using)
>       result = compiler.execute_sql(SINGLE)

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
result_type = 'single', chunked_fetch = False, chunk_size = 100

    def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
        """
        Run the query against the database and return the result(s). The
        return value is a single data item if result_type is SINGLE, or an
        iterator over the results if the result_type is MULTI.
    
        result_type is either MULTI (use fetchmany() to retrieve all rows),
        SINGLE (only retrieve a single row), or None. In this last case, the
        cursor is returned if any query is executed, since it's used by
        subclasses such as InsertQuery). It's possible, however, that no query
        is needed, as the filters describe an empty set. In that case, None is
        returned, to avoid any unnecessary database interaction.
        """
        result_type = result_type or NO_RESULTS
        try:
>           sql, params = self.as_sql()

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
with_limits = True, with_col_aliases = False

    def as_sql(self, with_limits=True, with_col_aliases=False):
        """
        Create the SQL for this query. Return the SQL string and list of
        parameters.
    
        If 'with_limits' is False, any limit/offset information is not included
        in the query.
        """
        refcounts_before = self.query.alias_refcount.copy()
        try:
            extra_select, order_by, group_by = self.pre_sql_setup()
            for_update_part = None
            # Is a LIMIT/OFFSET clause needed?
            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
            combinator = self.query.combinator
            features = self.connection.features
            if combinator:
                if not getattr(features, 'supports_select_{}'.format(combinator)):
                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
            else:
                distinct_fields, distinct_params = self.get_distinct()
                # This must come after 'select', 'ordering', and 'distinct'
                # (see docstring of get_from_clause() for details).
                from_, f_params = self.get_from_clause()
>               where, w_params = self.compile(self.where) if self.where is not None else ("", [])

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
node = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c469ea0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1c46aa40>, <django.db.models.lookups.Exact object at 0x7ebc1c46a110>)>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c469ea0>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1c46aa40>, <django.db.models.lookups.Exact object at 0x7ebc1c46a110>)>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        """
        Return the SQL version of the where clause and the value to be
        substituted in. Return '', [] if this node matches everything,
        None, [] if this node is empty, and raise EmptyResultSet if this
        node can't match anything.
        """
        result = []
        result_params = []
        if self.connector == AND:
            full_needed, empty_needed = len(self.children), 1
        else:
            full_needed, empty_needed = 1, len(self.children)
    
        for child in self.children:
            try:
>               sql, params = compiler.compile(child)

venv/lib/python3.10/site-packages/django/db/models/sql/where.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
node = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c469ea0>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c469ea0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        if isinstance(self.lhs, MultiColSource):
            assert self.rhs_is_direct_value()
            self.rhs = get_normalized_value(self.rhs, self.lhs)
            from django.db.models.sql.where import AND, WhereNode
            root_constraint = WhereNode()
            for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs):
                lookup_class = target.get_lookup(self.lookup_name)
                root_constraint.add(
                    lookup_class(target.get_col(self.lhs.alias, source), val), AND)
            return root_constraint.as_sql(compiler, connection)
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/fields/related_lookups.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c469ea0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        # Avoid comparison against direct rhs if lhs is a boolean value. That
        # turns "boolfield__exact=True" into "WHERE boolean_field" instead of
        # "WHERE boolean_field = True" when allowed.
        if (
            isinstance(self.rhs, bool) and
            getattr(self.lhs, 'conditional', False) and
            connection.ops.conditional_expression_supported_in_where_clause(self.lhs)
        ):
            lhs_sql, params = self.process_lhs(compiler, connection)
            template = '%s' if self.rhs else 'NOT %s'
            return template % lhs_sql, params
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c469ea0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        lhs_sql, params = self.process_lhs(compiler, connection)
>       rhs_sql, rhs_params = self.process_rhs(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c469ea0>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c5189a0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def process_rhs(self, compiler, connection):
        from django.db.models.sql.query import Query
        if isinstance(self.rhs, Query):
            if self.rhs.has_limit_one():
                if not self.rhs.has_select_fields:
                    self.rhs.clear_select_clause()
                    self.rhs.add_fields(['pk'])
            else:
>               raise ValueError(
                    'The QuerySet value for an exact lookup must be limited to '
                    'one result using slicing.'
                )
E               ValueError: The QuerySet value for an exact lookup must be limited to one result using slicing.

venv/lib/python3.10/site-packages/django/db/models/lookups.py:297: ValueError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7ebc1d249900>
user_client = <django.test.client.Client object at 0x7ebc1c377130>
many_posts_with_published_locations = [<Post: Soon Nor Game Crime Radio His>, <Post: Beat Parent Lot Response Hotel Somebody>, <Post: Next Life Cell Above W... Realize>, <Post: Decision Baby Others Truth Employee Your>, <Post: Section Determine This Home Teacher Behavior>, ...]

    def test_pagination(
        self, user_client, many_posts_with_published_locations
    ):
        posts = many_posts_with_published_locations
    
        assert len(posts) > self.profile_tester.n_per_page
        assert len(posts) > self.main_tester.n_per_page
        assert len(posts) > self.category_tester.n_per_page
    
        for (
            tester,
            response_get_func,
            ordering_err_msg,
            pagination_err_msg,
        ) in (
            (
                self.profile_tester,
                self.profile_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора работает"
                    " пагинация."
                ),
            ),
            (
                self.profile_tester,
                self.profile_tester.another_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора "
                    "пагинация работает в соответствии с заданием ."
                ),
            ),
            (
                self.main_tester,
                self.main_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст главной"
                    " страницы отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на главной странице "
                "пагинация работает в соответствии с заданием .",
            ),
            (
                self.category_tester,
                self.category_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " категории отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на странице категории "
                "пагинация работает в соответствии с заданием .",
            ),
        ):
>           response = response_get_func()

tests/test_content.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7ebc1c376b00>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_image_visible ________________________

self = <test_content.ProfilePostContentTester object at 0x7ebc1c6f2e90>
client = <django.test.client.Client object at 0x7ebc1c6f2c80>
url = '/profile/soniabaldwin/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c6f2c80>
path = '/profile/soniabaldwin/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c6f2c80>
path = '/profile/soniabaldwin/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c6f2c80>, method = 'GET'
path = '/profile/soniabaldwin/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/soniabaldwin/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/soniabaldwin/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c6f2c80>
request = {'PATH_INFO': '/profile/soniabaldwin/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=2kaxny2xp2nins1hxfiktg2a1uucsxwj', 'PATH_INFO': '/profile/soniabaldwin/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'is_email': True, 'unicode_hint': '', 'frames': [{'exc_ca...connection):'], 'pre_context_lineno': 290}}]], 'templates': [<django.template.base.Template object at 0x7ebc1c6f17b0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7ebc1da58f70>, {'templates': [<django.template.base.Template...process_rhs(compiler, connection)', '', '    def as_sql(self, compiler, connection):'], 'pre_context_lineno': 290}}]]})
signal_uid = 'template-render-139346394120128'
exception_uid = 'request-exception-139346394120128'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7ebc1c6f2c80>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/soniabaldwin/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7ebc1c6f1510>
request = <WSGIRequest: GET '/profile/soniabaldwin/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/soniabaldwin/'>, args = ()
kwargs = {'name_slug': 'soniabaldwin'}
self = <blog.views.ProfileListView object at 0x7ebc1c6f38b0>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c6f38b0>
request = <WSGIRequest: GET '/profile/soniabaldwin/'>, args = ()
kwargs = {'name_slug': 'soniabaldwin'}
handler = <bound method BaseListView.get of <blog.views.ProfileListView object at 0x7ebc1c6f38b0>>

    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
>       return handler(request, *args, **kwargs)

venv/lib/python3.10/site-packages/django/views/generic/base.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c6f38b0>
request = <WSGIRequest: GET '/profile/soniabaldwin/'>, args = ()
kwargs = {'name_slug': 'soniabaldwin'}, allow_empty = True

    def get(self, request, *args, **kwargs):
        self.object_list = self.get_queryset()
        allow_empty = self.get_allow_empty()
    
        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if self.get_paginate_by(self.object_list) is not None and hasattr(self.object_list, 'exists'):
                is_empty = not self.object_list.exists()
            else:
                is_empty = not self.object_list
            if is_empty:
                raise Http404(_('Empty list and “%(class_name)s.allow_empty” is False.') % {
                    'class_name': self.__class__.__name__,
                })
>       context = self.get_context_data()

venv/lib/python3.10/site-packages/django/views/generic/list.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c6f38b0>, kwargs = {}

    def get_context_data(self, **kwargs) -> dict:
        """Добавляет в контекст сведения о профиле пользователя."""
>       context: dict = super().get_context_data(**kwargs)

blogicum/blog/views.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c6f38b0>, object_list = None
kwargs = {}
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c6f0d60>
page_size = 10, context_object_name = 'post_list'

    def get_context_data(self, *, object_list=None, **kwargs):
        """Get the context for this view."""
        queryset = object_list if object_list is not None else self.object_list
        page_size = self.get_paginate_by(queryset)
        context_object_name = self.get_context_object_name(queryset)
        if page_size:
>           paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)

venv/lib/python3.10/site-packages/django/views/generic/list.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.ProfileListView object at 0x7ebc1c6f38b0>
queryset = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c6f0d60>
page_size = 10

    def paginate_queryset(self, queryset, page_size):
        """Paginate the queryset, if needed."""
        paginator = self.get_paginator(
            queryset, page_size, orphans=self.get_paginate_orphans(),
            allow_empty_first_page=self.get_allow_empty())
        page_kwarg = self.page_kwarg
        page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1
        try:
            page_number = int(page)
        except ValueError:
            if page == 'last':
                page_number = paginator.num_pages
            else:
                raise Http404(_('Page is not “last”, nor can it be converted to an int.'))
        try:
>           page = paginator.page(page_number)

venv/lib/python3.10/site-packages/django/views/generic/list.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c6f3280>, number = 1

    def page(self, number):
        """Return a Page object for the given 1-based page number."""
>       number = self.validate_number(number)

venv/lib/python3.10/site-packages/django/core/paginator.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c6f3280>, number = 1

    def validate_number(self, number):
        """Validate the given 1-based page number."""
        try:
            if isinstance(number, float) and not number.is_integer():
                raise ValueError
            number = int(number)
        except (TypeError, ValueError):
            raise PageNotAnInteger(_('That page number is not an integer'))
        if number < 1:
            raise EmptyPage(_('That page number is less than 1'))
>       if number > self.num_pages:

venv/lib/python3.10/site-packages/django/core/paginator.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28ddb0>
instance = <django.core.paginator.Paginator object at 0x7ebc1c6f3280>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c6f3280>

    @cached_property
    def num_pages(self):
        """Return the total number of pages."""
>       if self.count == 0 and not self.allow_empty_first_page:

venv/lib/python3.10/site-packages/django/core/paginator.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7ebc1e28dd50>
instance = <django.core.paginator.Paginator object at 0x7ebc1c6f3280>
cls = <class 'django.core.paginator.Paginator'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.10/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.core.paginator.Paginator object at 0x7ebc1c6f3280>

    @cached_property
    def count(self):
        """Return the total number of objects, across all pages."""
        c = getattr(self.object_list, 'count', None)
        if callable(c) and not inspect.isbuiltin(c) and method_has_no_args(c):
>           return c()

venv/lib/python3.10/site-packages/django/core/paginator.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.') raised in repr()] CustomQuerySet object at 0x7ebc1c6f0d60>

    def count(self):
        """
        Perform a SELECT COUNT() and return the number of records as an
        integer.
    
        If the QuerySet is already fully cached, return the length of the
        cached results set to avoid multiple SELECT COUNT(*) calls.
        """
        if self._result_cache is not None:
            return len(self._result_cache)
    
>       return self.query.get_count(using=self.db)

venv/lib/python3.10/site-packages/django/db/models/query.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1c6f3e20>
using = 'default'

    def get_count(self, using):
        """
        Perform a COUNT() query using the current filter constraints.
        """
        obj = self.clone()
        obj.add_annotation(Count('*'), alias='__count', is_summary=True)
>       number = obj.get_aggregation(using, ['__count'])['__count']

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.query.Query object at 0x7ebc1c6f3d30>
using = 'default', added_aggregate_names = ['__count']

    def get_aggregation(self, using, added_aggregate_names):
        """
        Return the dictionary with the values of the existing aggregations.
        """
        if not self.annotation_select:
            return {}
        existing_annotations = [
            annotation for alias, annotation
            in self.annotations.items()
            if alias not in added_aggregate_names
        ]
        # Decide if we need to use a subquery.
        #
        # Existing annotations would cause incorrect results as get_aggregation()
        # must produce just one result and thus must not use GROUP BY. But we
        # aren't smart enough to remove the existing annotations from the
        # query, so those would force us to use GROUP BY.
        #
        # If the query has limit or distinct, or uses set operations, then
        # those operations must be done in a subquery so that the query
        # aggregates on the limit and/or distinct results instead of applying
        # the distinct and limit after the aggregation.
        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or
                self.distinct or self.combinator):
            from django.db.models.sql.subqueries import AggregateQuery
            inner_query = self.clone()
            inner_query.subquery = True
            outer_query = AggregateQuery(self.model, inner_query)
            inner_query.select_for_update = False
            inner_query.select_related = False
            inner_query.set_annotation_mask(self.annotation_select)
            if not self.is_sliced and not self.distinct_fields:
                # Queries with distinct_fields need ordering and when a limit
                # is applied we must take the slice from the ordered query.
                # Otherwise no need for ordering.
                inner_query.clear_ordering(True)
            if not inner_query.distinct:
                # If the inner query uses default select and it has some
                # aggregate annotations, then we must make sure the inner
                # query is grouped by the main model's primary key. However,
                # clearing the select clause can alter results if distinct is
                # used.
                has_existing_aggregate_annotations = any(
                    annotation for annotation in existing_annotations
                    if getattr(annotation, 'contains_aggregate', True)
                )
                if inner_query.default_cols and has_existing_aggregate_annotations:
                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
                inner_query.default_cols = False
    
            relabels = {t: 'subquery' for t in inner_query.alias_map}
            relabels[None] = 'subquery'
            # Remove any aggregates marked for reduction from the subquery
            # and move them to the outer AggregateQuery.
            col_cnt = 0
            for alias, expression in list(inner_query.annotation_select.items()):
                annotation_select_mask = inner_query.annotation_select_mask
                if expression.is_summary:
                    expression, col_cnt = inner_query.rewrite_cols(expression, col_cnt)
                    outer_query.annotations[alias] = expression.relabeled_clone(relabels)
                    del inner_query.annotations[alias]
                    annotation_select_mask.remove(alias)
                # Make sure the annotation_select wont use cached results.
                inner_query.set_annotation_mask(inner_query.annotation_select_mask)
            if inner_query.select == () and not inner_query.default_cols and not inner_query.annotation_select_mask:
                # In case of Model.objects[0:3].count(), there would be no
                # field selected in the inner query, yet we must use a subquery.
                # So, make sure at least one field is selected.
                inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
        else:
            outer_query = self
            self.select = ()
            self.default_cols = False
            self.extra = {}
    
        outer_query.clear_ordering(True)
        outer_query.clear_limits()
        outer_query.select_for_update = False
        outer_query.select_related = False
        compiler = outer_query.get_compiler(using)
>       result = compiler.execute_sql(SINGLE)

venv/lib/python3.10/site-packages/django/db/models/sql/query.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
result_type = 'single', chunked_fetch = False, chunk_size = 100

    def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
        """
        Run the query against the database and return the result(s). The
        return value is a single data item if result_type is SINGLE, or an
        iterator over the results if the result_type is MULTI.
    
        result_type is either MULTI (use fetchmany() to retrieve all rows),
        SINGLE (only retrieve a single row), or None. In this last case, the
        cursor is returned if any query is executed, since it's used by
        subclasses such as InsertQuery). It's possible, however, that no query
        is needed, as the filters describe an empty set. In that case, None is
        returned, to avoid any unnecessary database interaction.
        """
        result_type = result_type or NO_RESULTS
        try:
>           sql, params = self.as_sql()

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
with_limits = True, with_col_aliases = False

    def as_sql(self, with_limits=True, with_col_aliases=False):
        """
        Create the SQL for this query. Return the SQL string and list of
        parameters.
    
        If 'with_limits' is False, any limit/offset information is not included
        in the query.
        """
        refcounts_before = self.query.alias_refcount.copy()
        try:
            extra_select, order_by, group_by = self.pre_sql_setup()
            for_update_part = None
            # Is a LIMIT/OFFSET clause needed?
            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
            combinator = self.query.combinator
            features = self.connection.features
            if combinator:
                if not getattr(features, 'supports_select_{}'.format(combinator)):
                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
            else:
                distinct_fields, distinct_params = self.get_distinct()
                # This must come after 'select', 'ordering', and 'distinct'
                # (see docstring of get_from_clause() for details).
                from_, f_params = self.get_from_clause()
>               where, w_params = self.compile(self.where) if self.where is not None else ("", [])

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
node = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c6f0c10>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1c6f0e50>, <django.db.models.lookups.Exact object at 0x7ebc1c6f19c0>)>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WhereNode: (AND: <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c6f0c10>, <django.db.models.l...b.models.lookups.LessThanOrEqual object at 0x7ebc1c6f0e50>, <django.db.models.lookups.Exact object at 0x7ebc1c6f19c0>)>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        """
        Return the SQL version of the where clause and the value to be
        substituted in. Return '', [] if this node matches everything,
        None, [] if this node is empty, and raise EmptyResultSet if this
        node can't match anything.
        """
        result = []
        result_params = []
        if self.connector == AND:
            full_needed, empty_needed = len(self.children), 1
        else:
            full_needed, empty_needed = 1, len(self.children)
    
        for child in self.children:
            try:
>               sql, params = compiler.compile(child)

venv/lib/python3.10/site-packages/django/db/models/sql/where.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
node = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c6f0c10>

    def compile(self, node):
        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
        if vendor_impl:
            sql, params = vendor_impl(self, self.connection)
        else:
>           sql, params = node.as_sql(self, self.connection)

venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c6f0c10>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        if isinstance(self.lhs, MultiColSource):
            assert self.rhs_is_direct_value()
            self.rhs = get_normalized_value(self.rhs, self.lhs)
            from django.db.models.sql.where import AND, WhereNode
            root_constraint = WhereNode()
            for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs):
                lookup_class = target.get_lookup(self.lookup_name)
                root_constraint.add(
                    lookup_class(target.get_col(self.lhs.alias, source), val), AND)
            return root_constraint.as_sql(compiler, connection)
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/fields/related_lookups.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c6f0c10>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        # Avoid comparison against direct rhs if lhs is a boolean value. That
        # turns "boolfield__exact=True" into "WHERE boolean_field" instead of
        # "WHERE boolean_field = True" when allowed.
        if (
            isinstance(self.rhs, bool) and
            getattr(self.lhs, 'conditional', False) and
            connection.ops.conditional_expression_supported_in_where_clause(self.lhs)
        ):
            lhs_sql, params = self.process_lhs(compiler, connection)
            template = '%s' if self.rhs else 'NOT %s'
            return template % lhs_sql, params
>       return super().as_sql(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c6f0c10>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def as_sql(self, compiler, connection):
        lhs_sql, params = self.process_lhs(compiler, connection)
>       rhs_sql, rhs_params = self.process_rhs(compiler, connection)

venv/lib/python3.10/site-packages/django/db/models/lookups.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c6f0c10>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c6f32b0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def process_rhs(self, compiler, connection):
        from django.db.models.sql.query import Query
        if isinstance(self.rhs, Query):
            if self.rhs.has_limit_one():
                if not self.rhs.has_select_fields:
                    self.rhs.clear_select_clause()
                    self.rhs.add_fields(['pk'])
            else:
>               raise ValueError(
                    'The QuerySet value for an exact lookup must be limited to '
                    'one result using slicing.'
                )
E               ValueError: The QuerySet value for an exact lookup must be limited to one result using slicing.

venv/lib/python3.10/site-packages/django/db/models/lookups.py:297: ValueError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7ebc1d24a8c0>
user_client = <django.test.client.Client object at 0x7ebc1c6f2c80>
post_with_published_location = <Post: Important Series Own Start Network You>

    def test_image_visible(self, user_client, post_with_published_location):
        post = post_with_published_location
        post_adapter = PostModelAdapter(post)
    
        testers: List[PostContentTester] = [
            self.profile_tester,
            self.main_tester,
            self.category_tester,
        ]
        img_n_with_post_img = {}
    
        for i, tester in enumerate(testers):
            img_soup_with_post_img = BeautifulSoup(
>               tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )

tests/test_content.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7ebc1c6f2e90>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x7ebc1c89d300>
user_client = <django.test.client.Client object at 0x7ebc1c89ce20>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
>               fpath = settings.TEMPLATES_DIR / "pages" / fname

tests/test_err_pages.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <LazySettings "None">, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        """Return the value of a setting and cache it in self.__dict__."""
        if self._wrapped is empty:
            self._setup(name)
>       val = getattr(self._wrapped, name)

venv/lib/python3.10/site-packages/django/conf/__init__.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <UserSettingsHolder>, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        if not name.isupper() or name in self._deleted:
            raise AttributeError
>       return getattr(self.default_settings, name)
E       AttributeError: 'Settings' object has no attribute 'TEMPLATES_DIR'

venv/lib/python3.10/site-packages/django/conf/__init__.py:239: AttributeError

During handling of the above exception, another exception occurred:

client = <django.test.client.Client object at 0x7ebc1c89d300>
user_client = <django.test.client.Client object at 0x7ebc1c89ce20>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
                fpath = settings.TEMPLATES_DIR / "pages" / fname
            except Exception as e:
>               raise AssertionError(
                    'Убедитесь, что переменная TEMPLATES_DIR в настройках проекта '
                    'является строкой (str) или объектом, соответствующим path-like интерфейсу '
                    '(например, экземпляром pathlib.Path). '
                    f'При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: {e}'
                )
E               AssertionError: Убедитесь, что переменная TEMPLATES_DIR в настройках проекта является строкой (str) или объектом, соответствующим path-like интерфейсу (например, экземпляром pathlib.Path). При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: 'Settings' object has no attribute 'TEMPLATES_DIR'

tests/test_err_pages.py:57: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x7ebc1c705300>

    @pytest.mark.django_db
    def test_custom_err_handlers(client):
        try:
            from blogicum import urls as blogicum_urls
        except Exception:
            raise AssertionError(
                "Убедитесь, в головном файле с маршрутами нет ошибок."
            )
        urls_src_squashed = squash_code(inspect.getsource(blogicum_urls))
        if "django.contrib.auth.urls" not in urls_src_squashed:
            raise AssertionError(
                "Убедитесь, что подключены маршруты для работы с пользователями из"
                " `django.contrib.auth.urls`."
            )
    
        def search_url_patterns(substring):
            resolver = get_resolver()
            results = []
    
            def search_patterns(head, patterns):
                for pattern in patterns:
                    if isinstance(pattern, URLPattern):
                        pattern_as_str = head + str(pattern.pattern)
                        if substring in pattern_as_str:
                            results.append(pattern)
                    elif isinstance(pattern, URLResolver):
                        search_patterns(
                            head + str(pattern.pattern), pattern.url_patterns
                        )
                return results
    
            search_patterns(head="", patterns=resolver.url_patterns)
    
            return results
    
        registration_url = "auth/registration/"
        auth_registration_patterns = search_url_patterns(registration_url)
>       assert auth_registration_patterns, (
            "Убедитесь, что в головном файле с маршрутами переопределён маршрут"
            f" `{registration_url}`."
        )
E       AssertionError: Убедитесь, что в головном файле с маршрутами переопределён маршрут `auth/registration/`.
E       assert []

tests/test_users.py:62: AssertionError
_________________________________ test_profile _________________________________

user = <User: isaiah27>, another_user = <User: ashleenorris>
user_client = <django.test.client.Client object at 0x7ebc1c847bb0>
another_user_client = <django.test.client.Client object at 0x7ebc1c845e40>
unlogged_client = <django.test.client.Client object at 0x7ebc1c8470d0>

    @pytest.mark.django_db
    def test_profile(
            user, another_user, user_client, another_user_client, unlogged_client
    ):
        user_url = f"/profile/{user.username}/"
        printed_url = "/profile/<username>/"
    
        User = get_user_model()
        status_code_not_404_err_msg = (
            "Убедитесь, что при обращении к странице несуществующего "
            "пользователя возвращается статус 404."
        )
        try:
>           response = user_client.get("/profile/this_is_unexisting_user_name/")

tests/test_users.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv/lib/python3.10/site-packages/django/views/generic/base.py:70: in view
    return self.dispatch(request, *args, **kwargs)
venv/lib/python3.10/site-packages/django/views/generic/base.py:98: in dispatch
    return handler(request, *args, **kwargs)
venv/lib/python3.10/site-packages/django/views/generic/list.py:157: in get
    context = self.get_context_data()
blogicum/blog/views.py:100: in get_context_data
    context: dict = super().get_context_data(**kwargs)
venv/lib/python3.10/site-packages/django/views/generic/list.py:119: in get_context_data
    paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)
venv/lib/python3.10/site-packages/django/views/generic/list.py:69: in paginate_queryset
    page = paginator.page(page_number)
venv/lib/python3.10/site-packages/django/core/paginator.py:76: in page
    number = self.validate_number(number)
venv/lib/python3.10/site-packages/django/core/paginator.py:54: in validate_number
    if number > self.num_pages:
venv/lib/python3.10/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.10/site-packages/django/core/paginator.py:103: in num_pages
    if self.count == 0 and not self.allow_empty_first_page:
venv/lib/python3.10/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.10/site-packages/django/core/paginator.py:97: in count
    return c()
venv/lib/python3.10/site-packages/django/db/models/query.py:412: in count
    return self.query.get_count(using=self.db)
venv/lib/python3.10/site-packages/django/db/models/sql/query.py:528: in get_count
    number = obj.get_aggregation(using, ['__count'])['__count']
venv/lib/python3.10/site-packages/django/db/models/sql/query.py:513: in get_aggregation
    result = compiler.execute_sql(SINGLE)
venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:1162: in execute_sql
    sql, params = self.as_sql()
venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:528: in as_sql
    where, w_params = self.compile(self.where) if self.where is not None else ("", [])
venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: in compile
    sql, params = node.as_sql(self, self.connection)
venv/lib/python3.10/site-packages/django/db/models/sql/where.py:81: in as_sql
    sql, params = compiler.compile(child)
venv/lib/python3.10/site-packages/django/db/models/sql/compiler.py:445: in compile
    sql, params = node.as_sql(self, self.connection)
venv/lib/python3.10/site-packages/django/db/models/fields/related_lookups.py:132: in as_sql
    return super().as_sql(compiler, connection)
venv/lib/python3.10/site-packages/django/db/models/lookups.py:315: in as_sql
    return super().as_sql(compiler, connection)
venv/lib/python3.10/site-packages/django/db/models/lookups.py:194: in as_sql
    rhs_sql, rhs_params = self.process_rhs(compiler, connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.fields.related_lookups.RelatedExact object at 0x7ebc1c846d40>
compiler = <django.db.models.sql.compiler.SQLCompiler object at 0x7ebc1c8447c0>
connection = <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x7ebc1e05f790>

    def process_rhs(self, compiler, connection):
        from django.db.models.sql.query import Query
        if isinstance(self.rhs, Query):
            if self.rhs.has_limit_one():
                if not self.rhs.has_select_fields:
                    self.rhs.clear_select_clause()
                    self.rhs.add_fields(['pk'])
            else:
>               raise ValueError(
                    'The QuerySet value for an exact lookup must be limited to '
                    'one result using slicing.'
                )
E               ValueError: The QuerySet value for an exact lookup must be limited to one result using slicing.

venv/lib/python3.10/site-packages/django/db/models/lookups.py:297: ValueError
__________________________________ test_post ___________________________________

self = <form.post.create_form_tester.CreatePostFormTester object at 0x7ebc1c7074f0>
form = <PostForm bound=True, valid=False, fields=(is_published;title;text;pub_date;location;category;image;comment_count)>
qs = <CustomQuerySet [<Post: Dinner Floor Off Clearly Concern Structure>]>
submitter = <form.base_form_tester.AnonymousSubmitTester object at 0x7ebc1ca5ec50>
assert_created = False

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        try:
>           return super().try_create_item(form, qs, submitter, assert_created)

tests/form/post/create_form_tester.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <form.post.create_form_tester.CreatePostFormTester object at 0x7ebc1c7074f0>
form = <PostForm bound=True, valid=False, fields=(is_published;title;text;pub_date;location;category;image;comment_count)>
qs = <CustomQuerySet [<Post: Dinner Floor Off Clearly Concern Structure>]>
submitter = <form.base_form_tester.AnonymousSubmitTester object at 0x7ebc1ca5ec50>
assert_created = False

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        if not form.is_valid():
>           raise FormValidationException(form.errors)
E           form.base_form_tester.FormValidationException: <ul class="errorlist"><li>comment_count<ul class="errorlist"><li>Обязательное поле.</li></ul></li></ul>

tests/form/base_form_tester.py:195: FormValidationException

The above exception was the direct cause of the following exception:

published_category = <Category: Debate Particular Knowledge Student Energy Network>
published_location = <Location: Aaron Montgomery PhD>
user_client = <django.test.client.Client object at 0x7ebc1c785480>
another_user_client = <django.test.client.Client object at 0x7ebc1c784f70>
unlogged_client = <django.test.client.Client object at 0x7ebc1c787280>
comment_to_a_post = <Comment: Specific eye according word help various nearly. Or from security race rest stop you. Relate beyond individual toward.
Wall option citizen language everybody heavy white.>
create_post_context_form_item = KeyVal(key='form', val=<PostForm bound=False, valid=False, fields=(is_published;title;text;pub_date;location;category;image;comment_count)>)
PostModel = <class 'blog.models.Post'>
CommentModelAdapter = <class 'adapters.comment.CommentModelAdapter.<locals>._CommentModelAdapter'>
main_content_tester = <test_content.MainPostContentTester object at 0x7ebc1cbc24d0>

    @pytest.mark.django_db(transaction=True)
    def test_post(
            published_category: Model,
            published_location: Model,
            user_client: django.test.Client,
            another_user_client: django.test.Client,
            unlogged_client: django.test.Client,
            comment_to_a_post: Model,
            create_post_context_form_item: Tuple[str, BaseForm],
            PostModel: Type[Model],
            CommentModelAdapter: CommentModelAdapterT,
            main_content_tester: MainPostContentTester
    ):
        _, ctx_form = create_post_context_form_item
    
        create_a_post_get_response = get_create_a_post_get_response_safely(
            user_client
        )
    
>       response_on_created, created_items = _test_create_items(
            PostModel,
            PostModelAdapter,
            another_user_client,
            create_a_post_get_response,
            ctx_form,
            published_category,
            published_location,
            unlogged_client,
            user_client,
        )

tests/test_post.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_post.py:298: in _test_create_items
    creation_tester.test_unlogged_cannot_create(
tests/form/post/create_form_tester.py:88: in test_unlogged_cannot_create
    super().test_unlogged_cannot_create(form, qs)
tests/form/base_form_tester.py:249: in test_unlogged_cannot_create
    self.test_create_item(
tests/form/base_form_tester.py:264: in test_create_item
    response, created = self.try_create_item(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <form.post.create_form_tester.CreatePostFormTester object at 0x7ebc1c7074f0>
form = <PostForm bound=True, valid=False, fields=(is_published;title;text;pub_date;location;category;image;comment_count)>
qs = <CustomQuerySet [<Post: Dinner Floor Off Clearly Concern Structure>]>
submitter = <form.base_form_tester.AnonymousSubmitTester object at 0x7ebc1ca5ec50>
assert_created = False

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        try:
            return super().try_create_item(form, qs, submitter, assert_created)
        except FormValidationException as e:
>           raise AssertionError(
                "При создании поста возникает ошибка:\n"
                f"{type(e).__name__}: {e}"
            ) from e
E           AssertionError: При создании поста возникает ошибка:
E           FormValidationException: <ul class="errorlist"><li>comment_count<ul class="errorlist"><li>Обязательное поле.</li></ul></li></ul>

tests/form/post/create_form_tester.py:79: AssertionError
=========================== short test summary info ============================
ERROR tests/test_comment.py::test_comment - django.urls.exceptions.NoReverseM...
ERROR tests/test_comment.py::test_404_on_comment_deleted_post - django.urls.e...
============= 10 failed, 13 passed, 13 warnings, 2 errors in 3.70s =============
