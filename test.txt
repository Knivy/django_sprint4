============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-7.1.3, pluggy-1.0.0 -- /home/albina/Dev/django_sprint4/venv/bin/python3
django: settings: blogicum.settings (from ini)
rootdir: /home/albina/Dev/django_sprint4, configfile: pytest.ini, testpaths: tests/
plugins: Faker-12.0.1, django-4.5.2
collecting ... collected 25 items

tests/test_content.py::TestContent::test_unpublished FAILED              [  4%]
tests/test_content.py::TestContent::test_only_own_pubs_in_category FAILED [  8%]
tests/test_content.py::TestContent::test_only_own_pubs_in_profile FAILED [ 12%]
tests/test_content.py::TestContent::test_unpublished_category FAILED     [ 16%]
tests/test_content.py::TestContent::test_future_posts FAILED             [ 20%]
tests/test_content.py::TestContent::test_pagination FAILED               [ 24%]
tests/test_content.py::TestContent::test_image_visible FAILED            [ 28%]
tests/test_err_pages.py::test_custom_err_handlers FAILED                 [ 32%]
tests/test_users.py::test_custom_err_handlers FAILED                     [ 36%]
tests/test_users.py::test_profile FAILED                                 [ 40%]
tests/test_comment.py::test_comment_created_at PASSED                    [ 44%]
tests/test_comment.py::test_comment ERROR                                [ 48%]
tests/test_comment.py::test_404_on_comment_deleted_post ERROR            [ 52%]
tests/test_post.py::test_post_created_at PASSED                          [ 56%]
tests/test_post.py::test_post ERROR                                      [ 60%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field] <- tests/conftest.py PASSED [ 64%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field] <- tests/conftest.py PASSED [ 68%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field] <- tests/conftest.py PASSED [ 72%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field] <- tests/conftest.py PASSED [ 76%]
tests/test_emails.py::test_gitignore PASSED                              [ 80%]
tests/test_emails.py::test_email_backend_settings PASSED                 [ 84%]
tests/test_err_pages.py::test_csrf_failure_view PASSED                   [ 88%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`image` field] <- tests/conftest.py PASSED [ 92%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`pub_date` field] <- tests/conftest.py PASSED [ 96%]
tests/test_static_pages.py::test_static_pages_as_cbv PASSED              [100%]

==================================== ERRORS ====================================
________________________ ERROR at setup of test_comment ________________________

user_client = <django.test.client.Client object at 0x7f62f11aab00>
post_with_published_location = <Post: Always Capital Audience Outside Hope Bad>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: in _get_response
    response = response.render()
venv/lib/python3.10/site-packages/django/template/response.py:105: in render
    self.content = self.rendered_content
venv/lib/python3.10/site-packages/django/template/response.py:83: in rendered_content
    return template.render(context, self._request)
venv/lib/python3.10/site-packages/django/template/backends/django.py:61: in render
    return self.template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:170: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: in render
    return compiled_parent._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:195: in render
    return template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:172: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:519: in render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: in render
    return nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
venv/lib/python3.10/site-packages/django/urls/base.py:86: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/albina/Dev/django_sprint4/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'profile', _prefix = '/', args = ('oliviaconway',), kwargs = {}
possibilities = [([('profile/%(pk)s/', ['pk'])], 'profile/(?P<pk>[0-9]+)/\\Z', {}, {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>})]
possibility = [('profile/%(pk)s/', ['pk'])]
pattern = 'profile/(?P<pk>[0-9]+)/\\Z', defaults = {}
converters = {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>}
result = 'profile/%(pk)s/', params = ['pk']
candidate_subs = {'pk': 'oliviaconway'}
text_candidate_subs = {'pk': 'oliviaconway'}, match = True

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'profile' with arguments '('oliviaconway',)' not found. 1 pattern(s) tried: ['profile/(?P<pk>[0-9]+)/\\Z']

venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch
______________ ERROR at setup of test_404_on_comment_deleted_post ______________

user_client = <django.test.client.Client object at 0x7f62f0dc1840>
post_with_published_location = <Post: Service Win Part Amount Brother Quality>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: in _get_response
    response = response.render()
venv/lib/python3.10/site-packages/django/template/response.py:105: in render
    self.content = self.rendered_content
venv/lib/python3.10/site-packages/django/template/response.py:83: in rendered_content
    return template.render(context, self._request)
venv/lib/python3.10/site-packages/django/template/backends/django.py:61: in render
    return self.template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:170: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: in render
    return compiled_parent._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:195: in render
    return template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:172: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:519: in render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: in render
    return nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
venv/lib/python3.10/site-packages/django/urls/base.py:86: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/albina/Dev/django_sprint4/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'profile', _prefix = '/', args = ('ntorres',), kwargs = {}
possibilities = [([('profile/%(pk)s/', ['pk'])], 'profile/(?P<pk>[0-9]+)/\\Z', {}, {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>})]
possibility = [('profile/%(pk)s/', ['pk'])]
pattern = 'profile/(?P<pk>[0-9]+)/\\Z', defaults = {}
converters = {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>}
result = 'profile/%(pk)s/', params = ['pk'], candidate_subs = {'pk': 'ntorres'}
text_candidate_subs = {'pk': 'ntorres'}, match = True

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'profile' with arguments '('ntorres',)' not found. 1 pattern(s) tried: ['profile/(?P<pk>[0-9]+)/\\Z']

venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch
_________________________ ERROR at setup of test_post __________________________

user_client = <django.test.client.Client object at 0x7f62f1003580>
post_with_published_location = <Post: Guy Sea Street She Budget Place>

    @pytest.fixture
    def create_post_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_create_a_post_get_response_safely(user_client)

tests/fixtures/posts.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:275: in get_create_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: in _get_response
    response = response.render()
venv/lib/python3.10/site-packages/django/template/response.py:105: in render
    self.content = self.rendered_content
venv/lib/python3.10/site-packages/django/template/response.py:83: in rendered_content
    return template.render(context, self._request)
venv/lib/python3.10/site-packages/django/template/backends/django.py:61: in render
    return self.template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:170: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: in render
    return compiled_parent._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/loader_tags.py:195: in render
    return template.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:172: in render
    return self._render(context)
venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:519: in render
    return self.nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: in render
    return nodelist.render(context)
venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
venv/lib/python3.10/site-packages/django/urls/base.py:86: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/albina/Dev/django_sprint4/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'profile', _prefix = '/', args = ('walter52',), kwargs = {}
possibilities = [([('profile/%(pk)s/', ['pk'])], 'profile/(?P<pk>[0-9]+)/\\Z', {}, {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>})]
possibility = [('profile/%(pk)s/', ['pk'])]
pattern = 'profile/(?P<pk>[0-9]+)/\\Z', defaults = {}
converters = {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>}
result = 'profile/%(pk)s/', params = ['pk'], candidate_subs = {'pk': 'walter52'}
text_candidate_subs = {'pk': 'walter52'}, match = True

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'profile' with arguments '('walter52',)' not found. 1 pattern(s) tried: ['profile/(?P<pk>[0-9]+)/\\Z']

venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch
=================================== FAILURES ===================================
_________________________ TestContent.test_unpublished _________________________

self = <test_content.ProfilePostContentTester object at 0x7f62f16bbb80>
client = <django.test.client.Client object at 0x7f62f165c070>
url = '/profile/pamelamullins/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7f62f1882fe0>
unpublished_posts_with_published_locations = [<Post: Phone Beyond Go Any Statement Majority>, <Post: Great View Professor Attention Single End>, <Post: Policy List Already Pressure Instead Price>]

    def test_unpublished(self, unpublished_posts_with_published_locations):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7f62f16bbb80>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
__________________ TestContent.test_only_own_pubs_in_category __________________

self = <test_content.CategoryPostContentTester object at 0x7f62f14fb430>
client = <django.test.client.Client object at 0x7f62f14fae60>
url = '/category/cause-shake-entire/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7f62f14fae60>
path = '/category/cause-shake-entire/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7f62f14fae60>
path = '/category/cause-shake-entire/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7f62f14fae60>, method = 'GET'
path = '/category/cause-shake-entire/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/cause-shake-entire/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/cause-shake-entire/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7f62f14fae60>
request = {'PATH_INFO': '/category/cause-shake-entire/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=zelqg3fel2xldf7uvwfpefci8mysy51c', 'PATH_INFO': '/category/cause-shake-entire/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....>, <django.template.base.Template object at 0x7f62f14a0730>, <django.template.base.Template object at 0x7f62f15975e0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7f62f20d0f70>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140062930239296'
exception_uid = 'request-exception-140062930239296'
response = <HttpResponseServerError status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7f62f14fae60>
response = <HttpResponseServerError status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/cause-shake-entire/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7f62f14fae90>
request = <WSGIRequest: GET '/category/cause-shake-entire/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7f62f14ef4c0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]
request = <WSGIRequest: GET '/category/cause-shake-entire/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7f62f14ef1c0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7f62f14ef1c0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7f62f14eebf0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7f62f14efbb0>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7f62f14ed2d0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.loader_tags.IncludeNode object at 0x7f62f14ed4b0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.loader_tags.IncludeNode object at 0x7f62f14ed4b0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv/lib/python3.10/site-packages/django/template/loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7f62f14a0730>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv/lib/python3.10/site-packages/django/template/base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7f62f14a0730>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7f62f14a3c70>, <TextNode: '\n<header>\n  <nav class="n'>, <django.t...ct at 0x7f62f14a3a90>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv/lib/python3.10/site-packages/django/template/defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje... object at 0x7f62f14a2f50>, <TextNode: '">\n              Правила\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x7f62f14a2cb0>, <TextNode: ...          '>, <django.template.defaulttags.URLNode object at 0x7f62f14a2260>, <TextNode: '">Выйти</a></button>\n    '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7f62f14a2b90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7f62f14a2b90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7f62...goryListView object at 0x7f62f14f0340>, 'category': <Category: Available White Administration Minute Exist Sometimes>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:profile', urlconf = 'blogicum.urls', args = ['dgilbert']
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/albina/Dev/django_sprint4/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'profile', _prefix = '/', args = ('dgilbert',), kwargs = {}
possibilities = [([('profile/%(pk)s/', ['pk'])], 'profile/(?P<pk>[0-9]+)/\\Z', {}, {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>})]
possibility = [('profile/%(pk)s/', ['pk'])]
pattern = 'profile/(?P<pk>[0-9]+)/\\Z', defaults = {}
converters = {'pk': <django.urls.converters.IntConverter object at 0x7f62f29fb0d0>}
result = 'profile/%(pk)s/', params = ['pk'], candidate_subs = {'pk': 'dgilbert'}
text_candidate_subs = {'pk': 'dgilbert'}, match = True

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'profile' with arguments '('dgilbert',)' not found. 1 pattern(s) tried: ['profile/(?P<pk>[0-9]+)/\\Z']

venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7f62f1883040>
user_client = <django.test.client.Client object at 0x7f62f14fae60>
post_with_published_location = <Post: Up Go Production Scene Suffer Life>
post_with_another_category = <Post: Design Back Once Listen Old Card>

    def test_only_own_pubs_in_category(
        self, user_client, post_with_published_location,
            post_with_another_category
    ):
>       response = self.category_tester.user_client_testget()

tests/test_content.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.CategoryPostContentTester object at 0x7f62f14fb430>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница категории загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница категории загружается без ошибок.

tests/test_content.py:266: AssertionError
__________________ TestContent.test_only_own_pubs_in_profile ___________________

self = <test_content.ProfilePostContentTester object at 0x7f62f1551c90>
client = <django.test.client.Client object at 0x7f62f15516c0>
url = '/profile/velezcesar/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7f62f1883670>
user_client = <django.test.client.Client object at 0x7f62f15516c0>
post_with_published_location = <Post: Choice Fill My Stage Couple Movie>
post_of_another_author = <Post: That Family Concern Security For Market>

    def test_only_own_pubs_in_profile(
            self, user_client, post_with_published_location,
            post_of_another_author
    ):
>       response = self.profile_tester.user_client_testget()

tests/test_content.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7f62f1551c90>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
____________________ TestContent.test_unpublished_category _____________________

self = <test_content.ProfilePostContentTester object at 0x7f62f10e6080>
client = <django.test.client.Client object at 0x7f62f10e55a0>
url = '/profile/bob84/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7f62f1883cd0>
user_client = <django.test.client.Client object at 0x7f62f10e55a0>
posts_with_unpublished_category = [<Post: If Central History Civil Expert Summer>, <Post: Decide Ten Sign Yeah Garden Reason>, <Post: Whether So Speak Would Amount Along>]

    def test_unpublished_category(
        self, user_client, posts_with_unpublished_category
    ):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7f62f10e6080>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_future_posts _________________________

self = <test_content.ProfilePostContentTester object at 0x7f62f15518d0>
client = <django.test.client.Client object at 0x7f62f1550be0>
url = '/profile/keithdominguez/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7f62f1883640>
user_client = <django.test.client.Client object at 0x7f62f1550be0>
future_posts = [<Post: Garden Reality Expect Huge Education Pick>, <Post: Blue Drop Organization Game New Why>, <Post: Industry Never Senior While Ok Throw>]

    def test_future_posts(self, user_client, future_posts):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:441: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7f62f15518d0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
_________________________ TestContent.test_pagination __________________________

self = <test_content.ProfilePostContentTester object at 0x7f62f10e4760>
client = <django.test.client.Client object at 0x7f62f10e7bb0>
url = '/profile/erik21/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7f62f185cd00>
user_client = <django.test.client.Client object at 0x7f62f10e7bb0>
many_posts_with_published_locations = [<Post: Happen Statement Color Decide Where Change>, <Post: Trial Professor Ability Outside Toward Kind>, <Post: Role ...n Third Join From>, <Post: Fact Instead Than Suffer Yet Other>, <Post: Over Focus Want Floor Administration Move>, ...]

    def test_pagination(
        self, user_client, many_posts_with_published_locations
    ):
        posts = many_posts_with_published_locations
    
        assert len(posts) > self.profile_tester.n_per_page
        assert len(posts) > self.main_tester.n_per_page
        assert len(posts) > self.category_tester.n_per_page
    
        for (
            tester,
            response_get_func,
            ordering_err_msg,
            pagination_err_msg,
        ) in (
            (
                self.profile_tester,
                self.profile_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора работает"
                    " пагинация."
                ),
            ),
            (
                self.profile_tester,
                self.profile_tester.another_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора "
                    "пагинация работает в соответствии с заданием ."
                ),
            ),
            (
                self.main_tester,
                self.main_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст главной"
                    " страницы отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на главной странице "
                "пагинация работает в соответствии с заданием .",
            ),
            (
                self.category_tester,
                self.category_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " категории отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на странице категории "
                "пагинация работает в соответствии с заданием .",
            ),
        ):
>           response = response_get_func()

tests/test_content.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7f62f10e4760>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_image_visible ________________________

self = <test_content.ProfilePostContentTester object at 0x7f62f11acd00>
client = <django.test.client.Client object at 0x7f62f16458d0>
url = '/profile/khamilton/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
            response = client.get(url)
            if response.status_code not in assert_status_in:
>               raise Exception
E               Exception

tests/test_content.py:100: Exception

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7f62f185cd30>
user_client = <django.test.client.Client object at 0x7f62f16458d0>
post_with_published_location = <Post: Yes Read Take Hold Pattern Ground>

    def test_image_visible(self, user_client, post_with_published_location):
        post = post_with_published_location
        post_adapter = PostModelAdapter(post)
    
        testers: List[PostContentTester] = [
            self.profile_tester,
            self.main_tester,
            self.category_tester,
        ]
        img_n_with_post_img = {}
    
        for i, tester in enumerate(testers):
            img_soup_with_post_img = BeautifulSoup(
>               tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )

tests/test_content.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7f62f11acd00>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x7f62f1080d30>
user_client = <django.test.client.Client object at 0x7f62f1080ca0>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
>               fpath = settings.TEMPLATES_DIR / "pages" / fname

tests/test_err_pages.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <LazySettings "None">, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        """Return the value of a setting and cache it in self.__dict__."""
        if self._wrapped is empty:
            self._setup(name)
>       val = getattr(self._wrapped, name)

venv/lib/python3.10/site-packages/django/conf/__init__.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <UserSettingsHolder>, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        if not name.isupper() or name in self._deleted:
            raise AttributeError
>       return getattr(self.default_settings, name)
E       AttributeError: 'Settings' object has no attribute 'TEMPLATES_DIR'

venv/lib/python3.10/site-packages/django/conf/__init__.py:239: AttributeError

During handling of the above exception, another exception occurred:

client = <django.test.client.Client object at 0x7f62f1080d30>
user_client = <django.test.client.Client object at 0x7f62f1080ca0>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
                fpath = settings.TEMPLATES_DIR / "pages" / fname
            except Exception as e:
>               raise AssertionError(
                    'Убедитесь, что переменная TEMPLATES_DIR в настройках проекта '
                    'является строкой (str) или объектом, соответствующим path-like интерфейсу '
                    '(например, экземпляром pathlib.Path). '
                    f'При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: {e}'
                )
E               AssertionError: Убедитесь, что переменная TEMPLATES_DIR в настройках проекта является строкой (str) или объектом, соответствующим path-like интерфейсу (например, экземпляром pathlib.Path). При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: 'Settings' object has no attribute 'TEMPLATES_DIR'

tests/test_err_pages.py:57: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x7f62f0f2aec0>

    @pytest.mark.django_db
    def test_custom_err_handlers(client):
        try:
            from blogicum import urls as blogicum_urls
        except Exception:
            raise AssertionError(
                "Убедитесь, в головном файле с маршрутами нет ошибок."
            )
        urls_src_squashed = squash_code(inspect.getsource(blogicum_urls))
        if "django.contrib.auth.urls" not in urls_src_squashed:
            raise AssertionError(
                "Убедитесь, что подключены маршруты для работы с пользователями из"
                " `django.contrib.auth.urls`."
            )
    
        def search_url_patterns(substring):
            resolver = get_resolver()
            results = []
    
            def search_patterns(head, patterns):
                for pattern in patterns:
                    if isinstance(pattern, URLPattern):
                        pattern_as_str = head + str(pattern.pattern)
                        if substring in pattern_as_str:
                            results.append(pattern)
                    elif isinstance(pattern, URLResolver):
                        search_patterns(
                            head + str(pattern.pattern), pattern.url_patterns
                        )
                return results
    
            search_patterns(head="", patterns=resolver.url_patterns)
    
            return results
    
        registration_url = "auth/registration/"
        auth_registration_patterns = search_url_patterns(registration_url)
>       assert auth_registration_patterns, (
            "Убедитесь, что в головном файле с маршрутами переопределён маршрут"
            f" `{registration_url}`."
        )
E       AssertionError: Убедитесь, что в головном файле с маршрутами переопределён маршрут `auth/registration/`.
E       assert []

tests/test_users.py:62: AssertionError
_________________________________ test_profile _________________________________

user = <User: tannersteve>, another_user = <User: gordonchristian>
user_client = <django.test.client.Client object at 0x7f62f10259f0>
another_user_client = <django.test.client.Client object at 0x7f62f10255d0>
unlogged_client = <django.test.client.Client object at 0x7f62f10241c0>

    @pytest.mark.django_db
    def test_profile(
            user, another_user, user_client, another_user_client, unlogged_client
    ):
        user_url = f"/profile/{user.username}/"
        printed_url = "/profile/<username>/"
    
        User = get_user_model()
        status_code_not_404_err_msg = (
            "Убедитесь, что при обращении к странице несуществующего "
            "пользователя возвращается статус 404."
        )
        try:
            response = user_client.get("/profile/this_is_unexisting_user_name/")
        except User.DoesNotExist:
            raise AssertionError(status_code_not_404_err_msg)
    
        assert response.status_code == HTTPStatus.NOT_FOUND, (
            status_code_not_404_err_msg)
    
        user_response: HttpResponse = user_client.get(user_url)
    
        user_content = user_response.content.decode("utf-8")
    
        anothers_same_page_response: HttpResponse = another_user_client.get(
            user_url
        )
        anothers_same_page_content = anothers_same_page_response.content.decode(
            "utf-8"
        )
    
        unlogged_same_page_response: HttpResponse = unlogged_client.get(user_url)
        unlogged_same_page_content = unlogged_same_page_response.content.decode(
            "utf-8"
        )
    
        for profile_user, profile_user_content in (
                (user, user_content),
                (user, unlogged_same_page_content),
                (user, anothers_same_page_content),
        ):
>           _test_user_info_displayed(
                profile_user, profile_user_content, printed_url
            )

tests/test_users.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

profile_user = <User: tannersteve>
profile_user_content = '\n<!doctype html>\n<html lang="en">\n<head>\n  <title>Not Found</title>\n</head>\n<body>\n  <h1>Not Found</h1><p>The requested resource was not found on this server.</p>\n</body>\n</html>\n'
printed_url = '/profile/<username>/'

    def _test_user_info_displayed(
            profile_user: Model, profile_user_content: str, printed_url: str
    ) -> None:
        if profile_user.first_name not in profile_user_content:
>           raise AssertionError(
                f"Убедитесь, что на странице `{printed_url}` отображается имя"
                " пользователя."
            )
E           AssertionError: Убедитесь, что на странице `/profile/<username>/` отображается имя пользователя.

tests/test_users.py:182: AssertionError
=========================== short test summary info ============================
ERROR tests/test_comment.py::test_comment - django.urls.exceptions.NoReverseM...
ERROR tests/test_comment.py::test_404_on_comment_deleted_post - django.urls.e...
ERROR tests/test_post.py::test_post - django.urls.exceptions.NoReverseMatch: ...
============= 10 failed, 12 passed, 5 warnings, 3 errors in 2.01s ==============
